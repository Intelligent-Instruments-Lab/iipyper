{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"reference/iipyper/__init__/","text":"Stopwatch Source code in src/iipyper/__init__.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 class Stopwatch : def __init__ ( self , punch = True ): self . t = None if punch : self . punch () def punch ( self , latency = 0 ): \"\"\"return elapsed time since last punch, then punch Args: latency: punch `latency` seconds in the past, unless it would be before the previous punch \"\"\" t = time . perf_counter_ns () - latency if self . t is None : dt_ns = 0 else : t = max ( self . t , t ) dt_ns = t - self . t self . t = t return dt_ns * 1e-9 def read ( self ): \"\"\"return elapsed time since last punch\"\"\" if self . t is None : return self . punch () return ( time . perf_counter_ns () - self . t ) * 1e-9 punch ( latency = 0 ) return elapsed time since last punch, then punch Parameters: Name Type Description Default latency punch latency seconds in the past, unless it would be before the previous punch 0 Source code in src/iipyper/__init__.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def punch ( self , latency = 0 ): \"\"\"return elapsed time since last punch, then punch Args: latency: punch `latency` seconds in the past, unless it would be before the previous punch \"\"\" t = time . perf_counter_ns () - latency if self . t is None : dt_ns = 0 else : t = max ( self . t , t ) dt_ns = t - self . t self . t = t return dt_ns * 1e-9 read () return elapsed time since last punch Source code in src/iipyper/__init__.py 91 92 93 94 95 def read ( self ): \"\"\"return elapsed time since last punch\"\"\" if self . t is None : return self . punch () return ( time . perf_counter_ns () - self . t ) * 1e-9 Timer a threading.Timer using the global iipyper lock around the timed function also starts automatically by default. Source code in src/iipyper/__init__.py 104 105 106 107 108 109 110 111 112 113 114 115 class Timer : \"\"\"a threading.Timer using the global iipyper lock around the timed function also starts automatically by default. \"\"\" def __init__ ( self , interval , f , lock = True , start = True , ** kw ): self . timer = _Timer ( max ( 0 , interval ), maybe_lock ( f , lock ), ** kw ) if start : self . start () def cancel ( self ): self . timer . cancel () def start ( self ): self . timer . start () cleanup ( f = None ) @cleanup decorator Source code in src/iipyper/__init__.py 175 176 177 178 179 180 181 182 183 184 def cleanup ( f = None ): \"\"\"@cleanup decorator\"\"\" def decorator ( f ): _cleanup_fns . append ( f ) return f if f is None : # return a decorator return decorator else : #bare decorator case; return decorated function return decorator ( f ) lock ( f ) wrap the decorated function with the global iipyper lock Source code in src/iipyper/__init__.py 187 188 189 190 191 192 def lock ( f ): \"\"\"wrap the decorated function with the global iipyper lock\"\"\" def decorated ( * a , ** kw ): with _lock : f ( * a , ** kw ) return decorated repeat ( interval = None , between_calls = False , lock = True , tick = 0.005 ) @repeat decorator Parameters: Name Type Description Default interval time in seconds to repeat at. If the decorated function returns a number, use that as the interval to the next call None between_calls if True, interval is between call and next call, if False, between return and next call False lock if True, use the global iipyper lock to make calls thread-safe True Source code in src/iipyper/__init__.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def repeat ( interval = None , between_calls = False , lock = True , tick = 5e-3 ): \"\"\"@repeat decorator Args: interval: time in seconds to repeat at. If the decorated function returns a number, use that as the interval to the next call between_calls: if True, interval is between call and next call, if False, between return and next call lock: if True, use the global iipyper lock to make calls thread-safe \"\"\" # close the decorator over interval and lock arguments def decorator ( f ): def g (): # clock = Clock(tick) while True : t = time . perf_counter () returned_interval = maybe_lock ( f , lock ) if isinstance ( returned_interval , Number ): wait_interval = returned_interval else : wait_interval = interval # replace False or None with 0 wait_interval = wait_interval or 0 if between_calls : # interval is between calls to the decorated function elapsed = time . perf_counter () - t wait = wait_interval - elapsed else : t = time . perf_counter () wait = wait_interval # else interval is between return of one and call and next call # print(f'{wait=}') # tt = time.perf_counter() if wait > 0 : sleep = wait - tick if sleep > 0 : time . sleep ( sleep ) spin_end = t + wait_interval while time . perf_counter () < spin_end : pass # print(f'waited = {time.perf_counter() - tt}') else : print ( f '@repeat function \" { f . __name__ } \" is late by { - wait } ' ) th = Thread ( target = g , daemon = True ) th . start () _threads . append ( th ) return decorator","title":"  init  "},{"location":"reference/iipyper/__init__/#iipyper.Stopwatch","text":"Source code in src/iipyper/__init__.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 class Stopwatch : def __init__ ( self , punch = True ): self . t = None if punch : self . punch () def punch ( self , latency = 0 ): \"\"\"return elapsed time since last punch, then punch Args: latency: punch `latency` seconds in the past, unless it would be before the previous punch \"\"\" t = time . perf_counter_ns () - latency if self . t is None : dt_ns = 0 else : t = max ( self . t , t ) dt_ns = t - self . t self . t = t return dt_ns * 1e-9 def read ( self ): \"\"\"return elapsed time since last punch\"\"\" if self . t is None : return self . punch () return ( time . perf_counter_ns () - self . t ) * 1e-9","title":"Stopwatch"},{"location":"reference/iipyper/__init__/#iipyper.Stopwatch.punch","text":"return elapsed time since last punch, then punch Parameters: Name Type Description Default latency punch latency seconds in the past, unless it would be before the previous punch 0 Source code in src/iipyper/__init__.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def punch ( self , latency = 0 ): \"\"\"return elapsed time since last punch, then punch Args: latency: punch `latency` seconds in the past, unless it would be before the previous punch \"\"\" t = time . perf_counter_ns () - latency if self . t is None : dt_ns = 0 else : t = max ( self . t , t ) dt_ns = t - self . t self . t = t return dt_ns * 1e-9","title":"punch()"},{"location":"reference/iipyper/__init__/#iipyper.Stopwatch.read","text":"return elapsed time since last punch Source code in src/iipyper/__init__.py 91 92 93 94 95 def read ( self ): \"\"\"return elapsed time since last punch\"\"\" if self . t is None : return self . punch () return ( time . perf_counter_ns () - self . t ) * 1e-9","title":"read()"},{"location":"reference/iipyper/__init__/#iipyper.Timer","text":"a threading.Timer using the global iipyper lock around the timed function also starts automatically by default. Source code in src/iipyper/__init__.py 104 105 106 107 108 109 110 111 112 113 114 115 class Timer : \"\"\"a threading.Timer using the global iipyper lock around the timed function also starts automatically by default. \"\"\" def __init__ ( self , interval , f , lock = True , start = True , ** kw ): self . timer = _Timer ( max ( 0 , interval ), maybe_lock ( f , lock ), ** kw ) if start : self . start () def cancel ( self ): self . timer . cancel () def start ( self ): self . timer . start ()","title":"Timer"},{"location":"reference/iipyper/__init__/#iipyper.cleanup","text":"@cleanup decorator Source code in src/iipyper/__init__.py 175 176 177 178 179 180 181 182 183 184 def cleanup ( f = None ): \"\"\"@cleanup decorator\"\"\" def decorator ( f ): _cleanup_fns . append ( f ) return f if f is None : # return a decorator return decorator else : #bare decorator case; return decorated function return decorator ( f )","title":"cleanup()"},{"location":"reference/iipyper/__init__/#iipyper.lock","text":"wrap the decorated function with the global iipyper lock Source code in src/iipyper/__init__.py 187 188 189 190 191 192 def lock ( f ): \"\"\"wrap the decorated function with the global iipyper lock\"\"\" def decorated ( * a , ** kw ): with _lock : f ( * a , ** kw ) return decorated","title":"lock()"},{"location":"reference/iipyper/__init__/#iipyper.repeat","text":"@repeat decorator Parameters: Name Type Description Default interval time in seconds to repeat at. If the decorated function returns a number, use that as the interval to the next call None between_calls if True, interval is between call and next call, if False, between return and next call False lock if True, use the global iipyper lock to make calls thread-safe True Source code in src/iipyper/__init__.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def repeat ( interval = None , between_calls = False , lock = True , tick = 5e-3 ): \"\"\"@repeat decorator Args: interval: time in seconds to repeat at. If the decorated function returns a number, use that as the interval to the next call between_calls: if True, interval is between call and next call, if False, between return and next call lock: if True, use the global iipyper lock to make calls thread-safe \"\"\" # close the decorator over interval and lock arguments def decorator ( f ): def g (): # clock = Clock(tick) while True : t = time . perf_counter () returned_interval = maybe_lock ( f , lock ) if isinstance ( returned_interval , Number ): wait_interval = returned_interval else : wait_interval = interval # replace False or None with 0 wait_interval = wait_interval or 0 if between_calls : # interval is between calls to the decorated function elapsed = time . perf_counter () - t wait = wait_interval - elapsed else : t = time . perf_counter () wait = wait_interval # else interval is between return of one and call and next call # print(f'{wait=}') # tt = time.perf_counter() if wait > 0 : sleep = wait - tick if sleep > 0 : time . sleep ( sleep ) spin_end = t + wait_interval while time . perf_counter () < spin_end : pass # print(f'waited = {time.perf_counter() - tt}') else : print ( f '@repeat function \" { f . __name__ } \" is late by { - wait } ' ) th = Thread ( target = g , daemon = True ) th . start () _threads . append ( th ) return decorator","title":"repeat()"},{"location":"reference/iipyper/audio/","text":"","title":"Audio"},{"location":"reference/iipyper/midi/","text":"MIDI Source code in src/iipyper/midi.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 class MIDI : \"\"\"\"\"\" @classmethod def print_ports ( cls ): print ( 'Available MIDI inputs:' ) for s in set ( mido . get_input_names ()): print ( f ' \\t { s } ' ) print ( 'Available MIDI outputs:' ) for s in set ( mido . get_output_names ()): print ( f ' \\t { s } ' ) MIDI . ports_printed = True ports_printed = False def __init__ ( self , in_ports = None , out_ports = None , virtual_in_ports = 1 , virtual_out_ports = 1 , verbose = 1 , sleep_time = 5e-4 ): \"\"\" Args: in_ports: list of input devices to open (uses all by default) out_ports: list of output devices to open (uses none by default) virtual_in_ports: number of 'To iipyper X' ports to create virtual_out_ports: number of 'From iipyper X' ports to create \"\"\" if not MIDI . ports_printed and verbose : MIDI . print_ports () self . running = False self . verbose = int ( verbose ) self . sleep_time = sleep_time # type -> list[Optional[set[port], Optional[set[channel]], function] self . handlers = [] if isinstance ( in_ports , str ): in_ports = in_ports . split ( ',' ) if isinstance ( out_ports , str ): out_ports = out_ports . split ( ',' ) # TODO: fuzzy match port names if in_ports is None or len ( in_ports ) == 0 : in_ports = set ( mido . get_input_names ()) self . in_ports = {} for i in range ( virtual_in_ports ): virtual_in = f 'To iipyper { i + 1 } ' self . in_ports [ virtual_in ] = mido . open_input ( virtual_in , virtual = True ) for port in in_ports : try : self . in_ports [ port ] = mido . open_input ( port , callback = self . get_callback ( port )) except Exception : print ( f \"\"\"WARNING: MIDI input { port } not found\"\"\" ) if self . verbose : print ( f \"\"\"opened MIDI input ports: { list ( self . in_ports ) } \"\"\" ) ##### WIP self . out_ports = {} for i in range ( virtual_out_ports ): virtual_out = f 'From iipyper { i + 1 } ' self . out_ports [ virtual_out ] = mido . open_output ( virtual_out , virtual = True ) if out_ports is None : out_ports = [] # if out_ports is None or len(out_ports)==0: # out_ports = set(mido.get_output_names()) # self.out_ports = {} for port in out_ports : try : self . out_ports [ port ] = mido . open_output ( port ) except Exception : print ( f \"\"\"WARNING: MIDI output { port } not found\"\"\" ) if self . verbose : print ( f \"\"\"opened MIDI output ports: { list ( self . out_ports ) } \"\"\" ) self . start () def start ( self ): self . running = True def handle ( self , * a , ** kw ): \"\"\"MIDI handler decorator Decorated function receives args: msg: mido message \"\"\" if len ( a ): # bare decorator assert len ( a ) == 1 assert len ( kw ) == 0 assert hasattr ( a [ 0 ], '__call__' ) f = a [ 0 ] filters = {} else : # with filter arguments for k in kw : assert k in { 'channel' , 'port' , 'type' , 'note' , 'velocity' , 'value' , 'control' , 'program' }, f 'unknown MIDI message filter \" { k } \"' filters = { k : _get_filter ( v ) for k , v in kw . items ()} f = None def decorator ( f ): self . handlers . append (( filters , f )) return f return decorator if f is None else decorator ( f ) def get_callback ( self , port_name ): # print(port_name) def callback ( msg ): if self . verbose > 1 : print ( f ' { msg =} ' ) if not self . running : return for filters , f in self . handlers : use_handler = ( 'port' not in filters or port_name in filters . pop ( 'port' )) use_handler &= all ( filt is None or not hasattr ( msg , k ) or getattr ( msg , k ) in filt for k , filt in filters . items ()) if use_handler : with _lock : print ( port_name ) f ( msg ) return callback def _send_msg ( self , port , m ): \"\"\"send on a specific port or all output ports\"\"\" ports = self . out_ports . values () if port is None else [ self . out_ports [ port ]] # print(ports) for p in ports : # print('iipyper send', m) # iiuc mido send should already be thread safe # with _lock: p . send ( m ) # # see https://mido.readthedocs.io/en/latest/message_types.html def send ( self , m , * a , port = None , ** kw ): \"\"\"send a mido message\"\"\" # print(f'SEND {time.perf_counter()}') if isinstance ( m , mido . Message ): self . _send_msg ( port , m ) if len ( a ) + len ( kw ) > 0 : print ( 'warning: extra arguments to MIDI send' ) elif isinstance ( m , str ): try : self . _send_msg ( port , mido . Message ( m , * a , ** kw )) except Exception : print ( 'MIDI send failed: bad arguments to mido.Message' ) raise else : print ( 'MIDI send failed: first argument should be a mido.Message or str' ) def __getattr__ ( self , name ): if name == 'cc' : name = 'control_change' if name == 'pc' : name = 'program_change' if name in ( 'note_on' , 'note_off' , 'polytouch' , 'control_change' , 'program_change' , 'aftertouch' , 'pitchwheel' , 'sysex' ): return lambda * a , ** kw : self . send ( name , * a , ** kw ) raise AttributeError __init__ ( in_ports = None , out_ports = None , virtual_in_ports = 1 , virtual_out_ports = 1 , verbose = 1 , sleep_time = 0.0005 ) Parameters: Name Type Description Default in_ports list of input devices to open (uses all by default) None out_ports list of output devices to open (uses none by default) None virtual_in_ports number of 'To iipyper X' ports to create 1 virtual_out_ports number of 'From iipyper X' ports to create 1 Source code in src/iipyper/midi.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def __init__ ( self , in_ports = None , out_ports = None , virtual_in_ports = 1 , virtual_out_ports = 1 , verbose = 1 , sleep_time = 5e-4 ): \"\"\" Args: in_ports: list of input devices to open (uses all by default) out_ports: list of output devices to open (uses none by default) virtual_in_ports: number of 'To iipyper X' ports to create virtual_out_ports: number of 'From iipyper X' ports to create \"\"\" if not MIDI . ports_printed and verbose : MIDI . print_ports () self . running = False self . verbose = int ( verbose ) self . sleep_time = sleep_time # type -> list[Optional[set[port], Optional[set[channel]], function] self . handlers = [] if isinstance ( in_ports , str ): in_ports = in_ports . split ( ',' ) if isinstance ( out_ports , str ): out_ports = out_ports . split ( ',' ) # TODO: fuzzy match port names if in_ports is None or len ( in_ports ) == 0 : in_ports = set ( mido . get_input_names ()) self . in_ports = {} for i in range ( virtual_in_ports ): virtual_in = f 'To iipyper { i + 1 } ' self . in_ports [ virtual_in ] = mido . open_input ( virtual_in , virtual = True ) for port in in_ports : try : self . in_ports [ port ] = mido . open_input ( port , callback = self . get_callback ( port )) except Exception : print ( f \"\"\"WARNING: MIDI input { port } not found\"\"\" ) if self . verbose : print ( f \"\"\"opened MIDI input ports: { list ( self . in_ports ) } \"\"\" ) ##### WIP self . out_ports = {} for i in range ( virtual_out_ports ): virtual_out = f 'From iipyper { i + 1 } ' self . out_ports [ virtual_out ] = mido . open_output ( virtual_out , virtual = True ) if out_ports is None : out_ports = [] # if out_ports is None or len(out_ports)==0: # out_ports = set(mido.get_output_names()) # self.out_ports = {} for port in out_ports : try : self . out_ports [ port ] = mido . open_output ( port ) except Exception : print ( f \"\"\"WARNING: MIDI output { port } not found\"\"\" ) if self . verbose : print ( f \"\"\"opened MIDI output ports: { list ( self . out_ports ) } \"\"\" ) self . start () handle ( * a , ** kw ) MIDI handler decorator Decorated function receives args msg: mido message Source code in src/iipyper/midi.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def handle ( self , * a , ** kw ): \"\"\"MIDI handler decorator Decorated function receives args: msg: mido message \"\"\" if len ( a ): # bare decorator assert len ( a ) == 1 assert len ( kw ) == 0 assert hasattr ( a [ 0 ], '__call__' ) f = a [ 0 ] filters = {} else : # with filter arguments for k in kw : assert k in { 'channel' , 'port' , 'type' , 'note' , 'velocity' , 'value' , 'control' , 'program' }, f 'unknown MIDI message filter \" { k } \"' filters = { k : _get_filter ( v ) for k , v in kw . items ()} f = None def decorator ( f ): self . handlers . append (( filters , f )) return f return decorator if f is None else decorator ( f ) send ( m , * a , port = None , ** kw ) send a mido message Source code in src/iipyper/midi.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 def send ( self , m , * a , port = None , ** kw ): \"\"\"send a mido message\"\"\" # print(f'SEND {time.perf_counter()}') if isinstance ( m , mido . Message ): self . _send_msg ( port , m ) if len ( a ) + len ( kw ) > 0 : print ( 'warning: extra arguments to MIDI send' ) elif isinstance ( m , str ): try : self . _send_msg ( port , mido . Message ( m , * a , ** kw )) except Exception : print ( 'MIDI send failed: bad arguments to mido.Message' ) raise else : print ( 'MIDI send failed: first argument should be a mido.Message or str' )","title":"Midi"},{"location":"reference/iipyper/midi/#iipyper.midi.MIDI","text":"Source code in src/iipyper/midi.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 class MIDI : \"\"\"\"\"\" @classmethod def print_ports ( cls ): print ( 'Available MIDI inputs:' ) for s in set ( mido . get_input_names ()): print ( f ' \\t { s } ' ) print ( 'Available MIDI outputs:' ) for s in set ( mido . get_output_names ()): print ( f ' \\t { s } ' ) MIDI . ports_printed = True ports_printed = False def __init__ ( self , in_ports = None , out_ports = None , virtual_in_ports = 1 , virtual_out_ports = 1 , verbose = 1 , sleep_time = 5e-4 ): \"\"\" Args: in_ports: list of input devices to open (uses all by default) out_ports: list of output devices to open (uses none by default) virtual_in_ports: number of 'To iipyper X' ports to create virtual_out_ports: number of 'From iipyper X' ports to create \"\"\" if not MIDI . ports_printed and verbose : MIDI . print_ports () self . running = False self . verbose = int ( verbose ) self . sleep_time = sleep_time # type -> list[Optional[set[port], Optional[set[channel]], function] self . handlers = [] if isinstance ( in_ports , str ): in_ports = in_ports . split ( ',' ) if isinstance ( out_ports , str ): out_ports = out_ports . split ( ',' ) # TODO: fuzzy match port names if in_ports is None or len ( in_ports ) == 0 : in_ports = set ( mido . get_input_names ()) self . in_ports = {} for i in range ( virtual_in_ports ): virtual_in = f 'To iipyper { i + 1 } ' self . in_ports [ virtual_in ] = mido . open_input ( virtual_in , virtual = True ) for port in in_ports : try : self . in_ports [ port ] = mido . open_input ( port , callback = self . get_callback ( port )) except Exception : print ( f \"\"\"WARNING: MIDI input { port } not found\"\"\" ) if self . verbose : print ( f \"\"\"opened MIDI input ports: { list ( self . in_ports ) } \"\"\" ) ##### WIP self . out_ports = {} for i in range ( virtual_out_ports ): virtual_out = f 'From iipyper { i + 1 } ' self . out_ports [ virtual_out ] = mido . open_output ( virtual_out , virtual = True ) if out_ports is None : out_ports = [] # if out_ports is None or len(out_ports)==0: # out_ports = set(mido.get_output_names()) # self.out_ports = {} for port in out_ports : try : self . out_ports [ port ] = mido . open_output ( port ) except Exception : print ( f \"\"\"WARNING: MIDI output { port } not found\"\"\" ) if self . verbose : print ( f \"\"\"opened MIDI output ports: { list ( self . out_ports ) } \"\"\" ) self . start () def start ( self ): self . running = True def handle ( self , * a , ** kw ): \"\"\"MIDI handler decorator Decorated function receives args: msg: mido message \"\"\" if len ( a ): # bare decorator assert len ( a ) == 1 assert len ( kw ) == 0 assert hasattr ( a [ 0 ], '__call__' ) f = a [ 0 ] filters = {} else : # with filter arguments for k in kw : assert k in { 'channel' , 'port' , 'type' , 'note' , 'velocity' , 'value' , 'control' , 'program' }, f 'unknown MIDI message filter \" { k } \"' filters = { k : _get_filter ( v ) for k , v in kw . items ()} f = None def decorator ( f ): self . handlers . append (( filters , f )) return f return decorator if f is None else decorator ( f ) def get_callback ( self , port_name ): # print(port_name) def callback ( msg ): if self . verbose > 1 : print ( f ' { msg =} ' ) if not self . running : return for filters , f in self . handlers : use_handler = ( 'port' not in filters or port_name in filters . pop ( 'port' )) use_handler &= all ( filt is None or not hasattr ( msg , k ) or getattr ( msg , k ) in filt for k , filt in filters . items ()) if use_handler : with _lock : print ( port_name ) f ( msg ) return callback def _send_msg ( self , port , m ): \"\"\"send on a specific port or all output ports\"\"\" ports = self . out_ports . values () if port is None else [ self . out_ports [ port ]] # print(ports) for p in ports : # print('iipyper send', m) # iiuc mido send should already be thread safe # with _lock: p . send ( m ) # # see https://mido.readthedocs.io/en/latest/message_types.html def send ( self , m , * a , port = None , ** kw ): \"\"\"send a mido message\"\"\" # print(f'SEND {time.perf_counter()}') if isinstance ( m , mido . Message ): self . _send_msg ( port , m ) if len ( a ) + len ( kw ) > 0 : print ( 'warning: extra arguments to MIDI send' ) elif isinstance ( m , str ): try : self . _send_msg ( port , mido . Message ( m , * a , ** kw )) except Exception : print ( 'MIDI send failed: bad arguments to mido.Message' ) raise else : print ( 'MIDI send failed: first argument should be a mido.Message or str' ) def __getattr__ ( self , name ): if name == 'cc' : name = 'control_change' if name == 'pc' : name = 'program_change' if name in ( 'note_on' , 'note_off' , 'polytouch' , 'control_change' , 'program_change' , 'aftertouch' , 'pitchwheel' , 'sysex' ): return lambda * a , ** kw : self . send ( name , * a , ** kw ) raise AttributeError","title":"MIDI"},{"location":"reference/iipyper/midi/#iipyper.midi.MIDI.__init__","text":"Parameters: Name Type Description Default in_ports list of input devices to open (uses all by default) None out_ports list of output devices to open (uses none by default) None virtual_in_ports number of 'To iipyper X' ports to create 1 virtual_out_ports number of 'From iipyper X' ports to create 1 Source code in src/iipyper/midi.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def __init__ ( self , in_ports = None , out_ports = None , virtual_in_ports = 1 , virtual_out_ports = 1 , verbose = 1 , sleep_time = 5e-4 ): \"\"\" Args: in_ports: list of input devices to open (uses all by default) out_ports: list of output devices to open (uses none by default) virtual_in_ports: number of 'To iipyper X' ports to create virtual_out_ports: number of 'From iipyper X' ports to create \"\"\" if not MIDI . ports_printed and verbose : MIDI . print_ports () self . running = False self . verbose = int ( verbose ) self . sleep_time = sleep_time # type -> list[Optional[set[port], Optional[set[channel]], function] self . handlers = [] if isinstance ( in_ports , str ): in_ports = in_ports . split ( ',' ) if isinstance ( out_ports , str ): out_ports = out_ports . split ( ',' ) # TODO: fuzzy match port names if in_ports is None or len ( in_ports ) == 0 : in_ports = set ( mido . get_input_names ()) self . in_ports = {} for i in range ( virtual_in_ports ): virtual_in = f 'To iipyper { i + 1 } ' self . in_ports [ virtual_in ] = mido . open_input ( virtual_in , virtual = True ) for port in in_ports : try : self . in_ports [ port ] = mido . open_input ( port , callback = self . get_callback ( port )) except Exception : print ( f \"\"\"WARNING: MIDI input { port } not found\"\"\" ) if self . verbose : print ( f \"\"\"opened MIDI input ports: { list ( self . in_ports ) } \"\"\" ) ##### WIP self . out_ports = {} for i in range ( virtual_out_ports ): virtual_out = f 'From iipyper { i + 1 } ' self . out_ports [ virtual_out ] = mido . open_output ( virtual_out , virtual = True ) if out_ports is None : out_ports = [] # if out_ports is None or len(out_ports)==0: # out_ports = set(mido.get_output_names()) # self.out_ports = {} for port in out_ports : try : self . out_ports [ port ] = mido . open_output ( port ) except Exception : print ( f \"\"\"WARNING: MIDI output { port } not found\"\"\" ) if self . verbose : print ( f \"\"\"opened MIDI output ports: { list ( self . out_ports ) } \"\"\" ) self . start ()","title":"__init__()"},{"location":"reference/iipyper/midi/#iipyper.midi.MIDI.handle","text":"MIDI handler decorator Decorated function receives args msg: mido message Source code in src/iipyper/midi.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def handle ( self , * a , ** kw ): \"\"\"MIDI handler decorator Decorated function receives args: msg: mido message \"\"\" if len ( a ): # bare decorator assert len ( a ) == 1 assert len ( kw ) == 0 assert hasattr ( a [ 0 ], '__call__' ) f = a [ 0 ] filters = {} else : # with filter arguments for k in kw : assert k in { 'channel' , 'port' , 'type' , 'note' , 'velocity' , 'value' , 'control' , 'program' }, f 'unknown MIDI message filter \" { k } \"' filters = { k : _get_filter ( v ) for k , v in kw . items ()} f = None def decorator ( f ): self . handlers . append (( filters , f )) return f return decorator if f is None else decorator ( f )","title":"handle()"},{"location":"reference/iipyper/midi/#iipyper.midi.MIDI.send","text":"send a mido message Source code in src/iipyper/midi.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 def send ( self , m , * a , port = None , ** kw ): \"\"\"send a mido message\"\"\" # print(f'SEND {time.perf_counter()}') if isinstance ( m , mido . Message ): self . _send_msg ( port , m ) if len ( a ) + len ( kw ) > 0 : print ( 'warning: extra arguments to MIDI send' ) elif isinstance ( m , str ): try : self . _send_msg ( port , mido . Message ( m , * a , ** kw )) except Exception : print ( 'MIDI send failed: bad arguments to mido.Message' ) raise else : print ( 'MIDI send failed: first argument should be a mido.Message or str' )","title":"send()"},{"location":"reference/iipyper/osc/","text":"OSC TODO: Handshake between server and clients TODO: Polling clients after handshake TODO: Enqueuing and buffering messages (?) Source code in src/iipyper/osc.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 class OSC (): \"\"\" TODO: Handshake between server and clients TODO: Polling clients after handshake TODO: Enqueuing and buffering messages (?) \"\"\" def __init__ ( self , host = \"127.0.0.1\" , port = 9999 , verbose = True , concurrent = False ): \"\"\" TODO: Expand to support multiple IPs + ports Args: host (str): IP address port (int): port to receive on verbose (bool): whether to print activity concurrent (bool): if True, handle each incoming OSC message on its own thread. otherwise, incoming OSC is handled serially on one thread for the whole OSC object. \"\"\" self . verbose = verbose self . concurrent = concurrent self . host = host self . port = port self . dispatcher = Dispatcher () self . server = None self . clients = {} # (host,port) -> client self . client_names = {} # (name) -> (host,port) self . create_server () def create_server ( self ): #, host=None, port=None): \"\"\" Create the server \"\"\" # if (host is None): # host = self.host # if (port is None): # port = self.port cls = ThreadingOSCUDPServer if self . concurrent else BlockingOSCUDPServer if ( self . server is None ): self . server = cls (( self . host , self . port ), self . dispatcher ) if self . verbose : print ( f \"OSC server created { self . host } : { self . port } \" ) # start the OSC server on its own thread Thread ( target = self . server . serve_forever , daemon = True ) . start () # self.server.serve_forever() else : print ( \"OSC server already exists\" ) # def close_server(self): # \"\"\" # Close the server # \"\"\" # if (self.server is not None): # self.transport.close() # else: # print(\"OSC server does not exist\") def add_handler ( self , address , handler ): \"\"\" Map the custom message handler to the OSC dispatcher \"\"\" # if (self.server is not None): self . dispatcher . map ( address , handler , needs_reply_address = True ) def create_client ( self , name , host = None , port = None ): \"\"\" Add an OSC client. Args: name: name this client host (int): IP to send to, defaults to same as server port (int): port to send to, defaults to 57120 (supercollider) \"\"\" if ( host == None ): host = self . host if ( port == None ): port = 57120 if (( host , port ) not in self . clients ): self . clients [ host , port ] = SimpleUDPClient ( host , port ) if self . verbose : print ( f \"OSC client created { host } : { port } \" ) else : print ( \"OSC client already exists\" ) self . client_names [ name ] = ( host , port ) def get_client_by_name ( self , name ): try : return self . clients [ self . client_names [ name ]] except Exception : print ( f 'no client with name \" { name } \"' ) return None def get_client_by_sender ( self , address ): if address not in self . clients : host , port = address self . create_client ( f ' { host } : { port } ' , host , port ) return self . clients [ address ] def send ( self , route , * msg , client = None ): \"\"\" Send message to default client, or with client in address Args: address: '/my/osc/route' or 'host:port/my/osc/route' *msg: content client: name of client or None \"\"\" if client is not None : client = self . get_client_by_name ( client ) elif ':' in route : try : client_str , route = route . split ( '/' , 1 ) assert ':' in client_str host , port = client_str . split ( ':' ) assert '/' not in host port = int ( port ) client = self . get_client_by_sender (( host , port )) except Exception : print ( f 'failed to get client address from OSC route \" { route } \"' ) else : client = next ( iter ( self . clients . values ())) if client is None : print ( f 'OSC message failed to send, could not determine client' ) return if not route . startswith ( '/' ): route = '/' + route client . send_message ( route , msg ) if self . verbose : print ( f \"OSC message sent { route } : { msg } \" ) def _decorate ( self , use_kwargs , route , return_host , return_port , json_keys ): \"\"\"generic decorator (args and kwargs cases)\"\"\" if hasattr ( route , '__call__' ): # bare decorator f = route route = None json_keys = set () else : f = None json_keys = set ( json_keys or []) def decorator ( f , route = route , return_host = return_host , return_port = return_port , json_keys = json_keys ): # default_route = f'/{f.__name__}/*' if route is None : route = f '/ { f . __name__ } ' # print(route) assert isinstance ( route , str ) and route . startswith ( '/' ) def handler ( client , address , * args ): \"\"\" Args: client: (host,port) of sender address: full OSC address *args: content of OSC message \"\"\" # print('handler:', client, address) if use_kwargs : kwargs = { k : v for k , v in zip ( args [:: 2 ], args [ 1 :: 2 ])} # JSON conversions for k in kwargs : do_json ( kwargs , k , json_keys , route ) args = [] else : kwargs = {} with _lock : r = f ( address , * args , ** kwargs ) # if there was a return value, # send it as a message back to the sender if r is not None : if not hasattr ( r , '__len__' ): print ( \"\"\" value returned from OSC handler should start with route \"\"\" ) else : client = ( client [ 0 ] if return_host is None else return_host , client [ 1 ] if return_port is None else return_port ) print ( client , r ) self . get_client_by_sender ( client ) . send_message ( r [ 0 ], r [ 1 :]) self . add_handler ( route , handler ) return f return decorator if f is None else decorator ( f ) def args ( self , route = None , return_host = None , return_port = None ): \"\"\"decorate a function as an args-style OSC handler. the decorated function should look like: def f(route, my_arg, my_arg2, ...): ... the OSC message will be converted to python types and passed as positional arguments. \"\"\" return self . _decorate ( False , route , return_host , return_port , None ) def kwargs ( self , route = None , return_host = None , return_port = None , json_keys = None ): \"\"\"decorate a function as an kwargs-style OSC handler. the decorated function should look like: def f(route, my_key=my_value, ...): ... the incoming OSC message should alternate argument names with values: /osc/route 'my_key' value 'my_key2' value ... Args: route: specify the OSC route. if None, use the function name json_keys: names of keyword arguments which should be decoded from JSON to python objects, in the case that they arrive as strings. alternatively, if a string starts with '%JSON:' it will be decoded. \"\"\" return self . _decorate ( True , route , return_host , return_port , json_keys ) def __call__ ( self , client , * a , ** kw ): \"\"\"alternate syntax for `send` with client name first\"\"\" self . send ( * a , client = client , ** kw ) __call__ ( client , * a , ** kw ) alternate syntax for send with client name first Source code in src/iipyper/osc.py 281 282 283 def __call__ ( self , client , * a , ** kw ): \"\"\"alternate syntax for `send` with client name first\"\"\" self . send ( * a , client = client , ** kw ) __init__ ( host = '127.0.0.1' , port = 9999 , verbose = True , concurrent = False ) TODO: Expand to support multiple IPs + ports Parameters: Name Type Description Default host str IP address '127.0.0.1' port int port to receive on 9999 verbose bool whether to print activity True concurrent bool if True, handle each incoming OSC message on its own thread. otherwise, incoming OSC is handled serially on one thread for the whole OSC object. False Source code in src/iipyper/osc.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def __init__ ( self , host = \"127.0.0.1\" , port = 9999 , verbose = True , concurrent = False ): \"\"\" TODO: Expand to support multiple IPs + ports Args: host (str): IP address port (int): port to receive on verbose (bool): whether to print activity concurrent (bool): if True, handle each incoming OSC message on its own thread. otherwise, incoming OSC is handled serially on one thread for the whole OSC object. \"\"\" self . verbose = verbose self . concurrent = concurrent self . host = host self . port = port self . dispatcher = Dispatcher () self . server = None self . clients = {} # (host,port) -> client self . client_names = {} # (name) -> (host,port) self . create_server () add_handler ( address , handler ) Map the custom message handler to the OSC dispatcher Source code in src/iipyper/osc.py 118 119 120 121 122 123 def add_handler ( self , address , handler ): \"\"\" Map the custom message handler to the OSC dispatcher \"\"\" # if (self.server is not None): self . dispatcher . map ( address , handler , needs_reply_address = True ) args ( route = None , return_host = None , return_port = None ) decorate a function as an args-style OSC handler. the decorated function should look like: def f(route, my_arg, my_arg2, ...): ... the OSC message will be converted to python types and passed as positional arguments. Source code in src/iipyper/osc.py 252 253 254 255 256 257 258 259 260 261 def args ( self , route = None , return_host = None , return_port = None ): \"\"\"decorate a function as an args-style OSC handler. the decorated function should look like: def f(route, my_arg, my_arg2, ...): ... the OSC message will be converted to python types and passed as positional arguments. \"\"\" return self . _decorate ( False , route , return_host , return_port , None ) create_client ( name , host = None , port = None ) Add an OSC client. Args: name: name this client host (int): IP to send to, defaults to same as server port (int): port to send to, defaults to 57120 (supercollider) Source code in src/iipyper/osc.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def create_client ( self , name , host = None , port = None ): \"\"\" Add an OSC client. Args: name: name this client host (int): IP to send to, defaults to same as server port (int): port to send to, defaults to 57120 (supercollider) \"\"\" if ( host == None ): host = self . host if ( port == None ): port = 57120 if (( host , port ) not in self . clients ): self . clients [ host , port ] = SimpleUDPClient ( host , port ) if self . verbose : print ( f \"OSC client created { host } : { port } \" ) else : print ( \"OSC client already exists\" ) self . client_names [ name ] = ( host , port ) create_server () Create the server Source code in src/iipyper/osc.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def create_server ( self ): #, host=None, port=None): \"\"\" Create the server \"\"\" # if (host is None): # host = self.host # if (port is None): # port = self.port cls = ThreadingOSCUDPServer if self . concurrent else BlockingOSCUDPServer if ( self . server is None ): self . server = cls (( self . host , self . port ), self . dispatcher ) if self . verbose : print ( f \"OSC server created { self . host } : { self . port } \" ) # start the OSC server on its own thread Thread ( target = self . server . serve_forever , daemon = True ) . start () # self.server.serve_forever() else : print ( \"OSC server already exists\" ) kwargs ( route = None , return_host = None , return_port = None , json_keys = None ) decorate a function as an kwargs-style OSC handler. the decorated function should look like: def f(route, my_key=my_value, ...): ... the incoming OSC message should alternate argument names with values: /osc/route 'my_key' value 'my_key2' value ... Parameters: Name Type Description Default route specify the OSC route. if None, use the function name None json_keys names of keyword arguments which should be decoded from JSON to python objects, in the case that they arrive as strings. alternatively, if a string starts with '%JSON:' it will be decoded. None Source code in src/iipyper/osc.py 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def kwargs ( self , route = None , return_host = None , return_port = None , json_keys = None ): \"\"\"decorate a function as an kwargs-style OSC handler. the decorated function should look like: def f(route, my_key=my_value, ...): ... the incoming OSC message should alternate argument names with values: /osc/route 'my_key' value 'my_key2' value ... Args: route: specify the OSC route. if None, use the function name json_keys: names of keyword arguments which should be decoded from JSON to python objects, in the case that they arrive as strings. alternatively, if a string starts with '%JSON:' it will be decoded. \"\"\" return self . _decorate ( True , route , return_host , return_port , json_keys ) send ( route , * msg , client = None ) Send message to default client, or with client in address Parameters: Name Type Description Default address '/my/osc/route' or 'host:port/my/osc/route' required *msg content () client name of client or None None Source code in src/iipyper/osc.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 def send ( self , route , * msg , client = None ): \"\"\" Send message to default client, or with client in address Args: address: '/my/osc/route' or 'host:port/my/osc/route' *msg: content client: name of client or None \"\"\" if client is not None : client = self . get_client_by_name ( client ) elif ':' in route : try : client_str , route = route . split ( '/' , 1 ) assert ':' in client_str host , port = client_str . split ( ':' ) assert '/' not in host port = int ( port ) client = self . get_client_by_sender (( host , port )) except Exception : print ( f 'failed to get client address from OSC route \" { route } \"' ) else : client = next ( iter ( self . clients . values ())) if client is None : print ( f 'OSC message failed to send, could not determine client' ) return if not route . startswith ( '/' ): route = '/' + route client . send_message ( route , msg ) if self . verbose : print ( f \"OSC message sent { route } : { msg } \" ) OSCReceiveListUpdater Bases: ReceiveListUpdater ReceiveListUpdater with an OSC handler Source code in src/iipyper/osc.py 391 392 393 394 395 396 397 398 399 400 401 402 403 class OSCReceiveListUpdater ( ReceiveListUpdater ): ''' ReceiveListUpdater with an OSC handler ''' def __init__ ( self , osc , address : str , f , state = None , count = 10 , update = False ): super () . __init__ ( f , state , count , update ) self . osc = osc self . address = address osc . add_handler ( self . address , self . receive ) def receive ( self , address , * args ): self . set ( list ( args [ 1 :])) OSCReceiveUpdater Bases: ReceiveUpdater ReceiveUpdater with an OSC handler Source code in src/iipyper/osc.py 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 class OSCReceiveUpdater ( ReceiveUpdater ): ''' ReceiveUpdater with an OSC handler ''' def __init__ ( self , osc , address : str , f , state = None , count = 10 , update = False ): super () . __init__ ( f , state , count , update ) self . osc = osc self . address = address osc . add_handler ( self . address , self . receive ) def receive ( self , address , * args ): # FIXME: ip:port/args ''' v: first argument to the handler is the IP:port of the sender v: or you can use dispatcher.map directly and not set needs_reply_address=True j: can I get ip:port from osc itself? v: if you know the sender ahead of time yeah, but that lets you respond to different senders dynamically ''' self . set ( args [ 1 :]) receive ( address , * args ) v: first argument to the handler is the IP:port of the sender v: or you can use dispatcher.map directly and not set needs_reply_address=True j: can I get ip:port from osc itself? v: if you know the sender ahead of time yeah, but that lets you respond to different senders dynamically Source code in src/iipyper/osc.py 379 380 381 382 383 384 385 386 387 388 389 def receive ( self , address , * args ): # FIXME: ip:port/args ''' v: first argument to the handler is the IP:port of the sender v: or you can use dispatcher.map directly and not set needs_reply_address=True j: can I get ip:port from osc itself? v: if you know the sender ahead of time yeah, but that lets you respond to different senders dynamically ''' self . set ( args [ 1 :]) OSCReceiveUpdaters o = OSCReceiveUpdaters(osc, {\"/tolvera/particles/pos\": s.osc_set_pos, \"/tolvera/particles/vel\": s.osc_set_vel}) Source code in src/iipyper/osc.py 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 class OSCReceiveUpdaters : ''' o = OSCReceiveUpdaters(osc, {\"/tolvera/particles/pos\": s.osc_set_pos, \"/tolvera/particles/vel\": s.osc_set_vel}) ''' def __init__ ( self , osc , receives = None , count = 10 ): self . osc = osc self . receives = [] self . count = count if receives is not None : self . add_dict ( receives , count = self . count ) def add_dict ( self , receives , count = None ): if count is None : count = self . count { a : self . add ( a , f , count = count ) for a , f in receives . items ()} def add ( self , address , function , state = None , count = None , update = False ): if count is None : count = self . count self . receives . append ( OSCReceiveUpdater ( self . osc , address , function , state , count , update )) def __call__ ( self ): [ r () for r in self . receives ] OSCSend Non rate-limited OSC send Source code in src/iipyper/osc.py 406 407 408 409 410 411 412 413 414 415 416 417 class OSCSend (): ''' Non rate-limited OSC send ''' def __init__ ( self , osc , address : str , f , count = 30 , client = None ): self . osc = osc self . address = address self . f = f self . client = client def __call__ ( self , * args ): self . osc . send ( self . address , * self . f ( * args ), client = self . client ) OSCSendUpdater Rate-limited OSC send Source code in src/iipyper/osc.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 class OSCSendUpdater (): ''' Rate-limited OSC send ''' def __init__ ( self , osc , address : str , f , count = 30 , client = None ): self . osc = osc self . address = address self . f = f self . count = count self . counter = 0 self . client = client def __call__ ( self ): self . counter += 1 if self . counter >= self . count : self . osc . send ( self . address , * self . f (), client = self . client ) self . counter = 0 OSCSendUpdaters o = OSCSendUpdaters(osc, client=\"particles\", count=10, sends={ \"/tolvera/particles/get/pos/all\": s.osc_get_pos_all }) Source code in src/iipyper/osc.py 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 class OSCSendUpdaters : ''' o = OSCSendUpdaters(osc, client=\"particles\", count=10, sends={ \"/tolvera/particles/get/pos/all\": s.osc_get_pos_all }) ''' def __init__ ( self , osc , sends = None , count = 10 , client = None ): self . osc = osc self . sends = [] self . count = count self . client = client if sends is not None : self . add_dict ( sends , self . count , self . client ) def add_dict ( self , sends , count = None , client = None ): if count is None : count = self . count if client is None : client = self . client { a : self . add ( a , f , count = count , client = client ) for a , f in sends . items ()} def add ( self , address , function , state = None , count = None , update = False , client = None ): if count is None : count = self . count if client is None : client = self . client self . sends . append ( OSCSendUpdater ( self . osc , address , function , count , client )) def __call__ ( self ): [ s () for s in self . sends ] OSCUpdaters o = OSCUpdaters(osc, client=\"boids\", count=10, receives={ \"/tolvera/boids/pos\": b.osc_set_pos, \"/tolvera/boids/vel\": b.osc_set_vel }, sends={ \"/tolvera/boids/pos/all\": b.osc_get_all_pos } ) Source code in src/iipyper/osc.py 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 class OSCUpdaters : ''' o = OSCUpdaters(osc, client=\"boids\", count=10, receives={ \"/tolvera/boids/pos\": b.osc_set_pos, \"/tolvera/boids/vel\": b.osc_set_vel }, sends={ \"/tolvera/boids/pos/all\": b.osc_get_all_pos } ) ''' def __init__ ( self , osc , sends = None , receives = None , send_count = 60 , receive_count = 10 , client = None ): self . osc = osc self . client = client self . send_count = send_count self . receive_count = receive_count self . sends = OSCSendUpdaters ( self . osc , count = self . send_count , client = self . client ) self . receives = OSCReceiveUpdaters ( self . osc , count = self . receive_count ) if sends is not None : self . add_sends ( sends ) if receives is not None : self . add_receives ( receives ) def add_sends ( self , sends , count = None , client = None ): if count is None : count = self . send_count if client is None : client = self . client self . sends . add_dict ( sends , count , client ) def add_send ( self , send , count = None , client = None ): if count is None : count = self . send_count if client is None : client = self . client self . sends . add ( send , client = client , count = count ) def add_receives ( self , receives , count = None ): if count is None : count = self . receive_count self . receives . add_dict ( receives , count = count ) def add_receive ( self , receive , count = None ): if count is None : count = self . receive_count self . receives . add ( receive , count = count ) def __call__ ( self ): self . sends () self . receives () ReceiveListUpdater Decouples event handling from updating Updating is rate-limited by a counter Assumes a list[float] instead of *args Source code in src/iipyper/osc.py 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 class ReceiveListUpdater : ''' Decouples event handling from updating Updating is rate-limited by a counter Assumes a list[float] instead of *args ''' def __init__ ( self , f , state = None , count = 5 , update = False ): self . f = f self . count = count self . counter = 0 self . update = update self . state = state def set ( self , state ): ''' Set the Updater's state ''' self . state = state self . update = True def __call__ ( self ): ''' Update the target function with internal state ''' self . counter += 1 if not ( self . update and self . counter > self . count and self . state is not None ): return self . f ( self . state ) self . counter = 0 self . update = False __call__ () Update the target function with internal state Source code in src/iipyper/osc.py 355 356 357 358 359 360 361 362 363 364 365 366 def __call__ ( self ): ''' Update the target function with internal state ''' self . counter += 1 if not ( self . update and self . counter > self . count and self . state is not None ): return self . f ( self . state ) self . counter = 0 self . update = False set ( state ) Set the Updater's state Source code in src/iipyper/osc.py 348 349 350 351 352 353 def set ( self , state ): ''' Set the Updater's state ''' self . state = state self . update = True ReceiveUpdater Decouples event handling from updating Updating is rate-limited by a counter Source code in src/iipyper/osc.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 class ReceiveUpdater : ''' Decouples event handling from updating Updating is rate-limited by a counter ''' def __init__ ( self , f , state = None , count = 5 , update = False ): self . f = f self . count = count self . counter = 0 self . update = update self . state = state def set ( self , state ): ''' Set the Updater's state ''' self . state = state self . update = True def __call__ ( self ): ''' Update the target function with internal state ''' self . counter += 1 if not ( self . update and self . counter > self . count and self . state is not None ): return self . f ( * self . state ) self . counter = 0 self . update = False __call__ () Update the target function with internal state Source code in src/iipyper/osc.py 321 322 323 324 325 326 327 328 329 330 331 332 def __call__ ( self ): ''' Update the target function with internal state ''' self . counter += 1 if not ( self . update and self . counter > self . count and self . state is not None ): return self . f ( * self . state ) self . counter = 0 self . update = False set ( state ) Set the Updater's state Source code in src/iipyper/osc.py 314 315 316 317 318 319 def set ( self , state ): ''' Set the Updater's state ''' self . state = state self . update = True Updater Rate-limited function call Source code in src/iipyper/osc.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 class Updater (): ''' Rate-limited function call ''' def __init__ ( self , f , count = 30 ): self . f = f self . count = count self . counter = 0 def __call__ ( self ): self . counter += 1 if self . counter >= self . count : self . f () self . counter = 0","title":"Osc"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC","text":"TODO: Handshake between server and clients TODO: Polling clients after handshake TODO: Enqueuing and buffering messages (?) Source code in src/iipyper/osc.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 class OSC (): \"\"\" TODO: Handshake between server and clients TODO: Polling clients after handshake TODO: Enqueuing and buffering messages (?) \"\"\" def __init__ ( self , host = \"127.0.0.1\" , port = 9999 , verbose = True , concurrent = False ): \"\"\" TODO: Expand to support multiple IPs + ports Args: host (str): IP address port (int): port to receive on verbose (bool): whether to print activity concurrent (bool): if True, handle each incoming OSC message on its own thread. otherwise, incoming OSC is handled serially on one thread for the whole OSC object. \"\"\" self . verbose = verbose self . concurrent = concurrent self . host = host self . port = port self . dispatcher = Dispatcher () self . server = None self . clients = {} # (host,port) -> client self . client_names = {} # (name) -> (host,port) self . create_server () def create_server ( self ): #, host=None, port=None): \"\"\" Create the server \"\"\" # if (host is None): # host = self.host # if (port is None): # port = self.port cls = ThreadingOSCUDPServer if self . concurrent else BlockingOSCUDPServer if ( self . server is None ): self . server = cls (( self . host , self . port ), self . dispatcher ) if self . verbose : print ( f \"OSC server created { self . host } : { self . port } \" ) # start the OSC server on its own thread Thread ( target = self . server . serve_forever , daemon = True ) . start () # self.server.serve_forever() else : print ( \"OSC server already exists\" ) # def close_server(self): # \"\"\" # Close the server # \"\"\" # if (self.server is not None): # self.transport.close() # else: # print(\"OSC server does not exist\") def add_handler ( self , address , handler ): \"\"\" Map the custom message handler to the OSC dispatcher \"\"\" # if (self.server is not None): self . dispatcher . map ( address , handler , needs_reply_address = True ) def create_client ( self , name , host = None , port = None ): \"\"\" Add an OSC client. Args: name: name this client host (int): IP to send to, defaults to same as server port (int): port to send to, defaults to 57120 (supercollider) \"\"\" if ( host == None ): host = self . host if ( port == None ): port = 57120 if (( host , port ) not in self . clients ): self . clients [ host , port ] = SimpleUDPClient ( host , port ) if self . verbose : print ( f \"OSC client created { host } : { port } \" ) else : print ( \"OSC client already exists\" ) self . client_names [ name ] = ( host , port ) def get_client_by_name ( self , name ): try : return self . clients [ self . client_names [ name ]] except Exception : print ( f 'no client with name \" { name } \"' ) return None def get_client_by_sender ( self , address ): if address not in self . clients : host , port = address self . create_client ( f ' { host } : { port } ' , host , port ) return self . clients [ address ] def send ( self , route , * msg , client = None ): \"\"\" Send message to default client, or with client in address Args: address: '/my/osc/route' or 'host:port/my/osc/route' *msg: content client: name of client or None \"\"\" if client is not None : client = self . get_client_by_name ( client ) elif ':' in route : try : client_str , route = route . split ( '/' , 1 ) assert ':' in client_str host , port = client_str . split ( ':' ) assert '/' not in host port = int ( port ) client = self . get_client_by_sender (( host , port )) except Exception : print ( f 'failed to get client address from OSC route \" { route } \"' ) else : client = next ( iter ( self . clients . values ())) if client is None : print ( f 'OSC message failed to send, could not determine client' ) return if not route . startswith ( '/' ): route = '/' + route client . send_message ( route , msg ) if self . verbose : print ( f \"OSC message sent { route } : { msg } \" ) def _decorate ( self , use_kwargs , route , return_host , return_port , json_keys ): \"\"\"generic decorator (args and kwargs cases)\"\"\" if hasattr ( route , '__call__' ): # bare decorator f = route route = None json_keys = set () else : f = None json_keys = set ( json_keys or []) def decorator ( f , route = route , return_host = return_host , return_port = return_port , json_keys = json_keys ): # default_route = f'/{f.__name__}/*' if route is None : route = f '/ { f . __name__ } ' # print(route) assert isinstance ( route , str ) and route . startswith ( '/' ) def handler ( client , address , * args ): \"\"\" Args: client: (host,port) of sender address: full OSC address *args: content of OSC message \"\"\" # print('handler:', client, address) if use_kwargs : kwargs = { k : v for k , v in zip ( args [:: 2 ], args [ 1 :: 2 ])} # JSON conversions for k in kwargs : do_json ( kwargs , k , json_keys , route ) args = [] else : kwargs = {} with _lock : r = f ( address , * args , ** kwargs ) # if there was a return value, # send it as a message back to the sender if r is not None : if not hasattr ( r , '__len__' ): print ( \"\"\" value returned from OSC handler should start with route \"\"\" ) else : client = ( client [ 0 ] if return_host is None else return_host , client [ 1 ] if return_port is None else return_port ) print ( client , r ) self . get_client_by_sender ( client ) . send_message ( r [ 0 ], r [ 1 :]) self . add_handler ( route , handler ) return f return decorator if f is None else decorator ( f ) def args ( self , route = None , return_host = None , return_port = None ): \"\"\"decorate a function as an args-style OSC handler. the decorated function should look like: def f(route, my_arg, my_arg2, ...): ... the OSC message will be converted to python types and passed as positional arguments. \"\"\" return self . _decorate ( False , route , return_host , return_port , None ) def kwargs ( self , route = None , return_host = None , return_port = None , json_keys = None ): \"\"\"decorate a function as an kwargs-style OSC handler. the decorated function should look like: def f(route, my_key=my_value, ...): ... the incoming OSC message should alternate argument names with values: /osc/route 'my_key' value 'my_key2' value ... Args: route: specify the OSC route. if None, use the function name json_keys: names of keyword arguments which should be decoded from JSON to python objects, in the case that they arrive as strings. alternatively, if a string starts with '%JSON:' it will be decoded. \"\"\" return self . _decorate ( True , route , return_host , return_port , json_keys ) def __call__ ( self , client , * a , ** kw ): \"\"\"alternate syntax for `send` with client name first\"\"\" self . send ( * a , client = client , ** kw )","title":"OSC"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.__call__","text":"alternate syntax for send with client name first Source code in src/iipyper/osc.py 281 282 283 def __call__ ( self , client , * a , ** kw ): \"\"\"alternate syntax for `send` with client name first\"\"\" self . send ( * a , client = client , ** kw )","title":"__call__()"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.__init__","text":"TODO: Expand to support multiple IPs + ports Parameters: Name Type Description Default host str IP address '127.0.0.1' port int port to receive on 9999 verbose bool whether to print activity True concurrent bool if True, handle each incoming OSC message on its own thread. otherwise, incoming OSC is handled serially on one thread for the whole OSC object. False Source code in src/iipyper/osc.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def __init__ ( self , host = \"127.0.0.1\" , port = 9999 , verbose = True , concurrent = False ): \"\"\" TODO: Expand to support multiple IPs + ports Args: host (str): IP address port (int): port to receive on verbose (bool): whether to print activity concurrent (bool): if True, handle each incoming OSC message on its own thread. otherwise, incoming OSC is handled serially on one thread for the whole OSC object. \"\"\" self . verbose = verbose self . concurrent = concurrent self . host = host self . port = port self . dispatcher = Dispatcher () self . server = None self . clients = {} # (host,port) -> client self . client_names = {} # (name) -> (host,port) self . create_server ()","title":"__init__()"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.add_handler","text":"Map the custom message handler to the OSC dispatcher Source code in src/iipyper/osc.py 118 119 120 121 122 123 def add_handler ( self , address , handler ): \"\"\" Map the custom message handler to the OSC dispatcher \"\"\" # if (self.server is not None): self . dispatcher . map ( address , handler , needs_reply_address = True )","title":"add_handler()"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.args","text":"decorate a function as an args-style OSC handler. the decorated function should look like: def f(route, my_arg, my_arg2, ...): ... the OSC message will be converted to python types and passed as positional arguments. Source code in src/iipyper/osc.py 252 253 254 255 256 257 258 259 260 261 def args ( self , route = None , return_host = None , return_port = None ): \"\"\"decorate a function as an args-style OSC handler. the decorated function should look like: def f(route, my_arg, my_arg2, ...): ... the OSC message will be converted to python types and passed as positional arguments. \"\"\" return self . _decorate ( False , route , return_host , return_port , None )","title":"args()"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.create_client","text":"Add an OSC client. Args: name: name this client host (int): IP to send to, defaults to same as server port (int): port to send to, defaults to 57120 (supercollider) Source code in src/iipyper/osc.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def create_client ( self , name , host = None , port = None ): \"\"\" Add an OSC client. Args: name: name this client host (int): IP to send to, defaults to same as server port (int): port to send to, defaults to 57120 (supercollider) \"\"\" if ( host == None ): host = self . host if ( port == None ): port = 57120 if (( host , port ) not in self . clients ): self . clients [ host , port ] = SimpleUDPClient ( host , port ) if self . verbose : print ( f \"OSC client created { host } : { port } \" ) else : print ( \"OSC client already exists\" ) self . client_names [ name ] = ( host , port )","title":"create_client()"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.create_server","text":"Create the server Source code in src/iipyper/osc.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def create_server ( self ): #, host=None, port=None): \"\"\" Create the server \"\"\" # if (host is None): # host = self.host # if (port is None): # port = self.port cls = ThreadingOSCUDPServer if self . concurrent else BlockingOSCUDPServer if ( self . server is None ): self . server = cls (( self . host , self . port ), self . dispatcher ) if self . verbose : print ( f \"OSC server created { self . host } : { self . port } \" ) # start the OSC server on its own thread Thread ( target = self . server . serve_forever , daemon = True ) . start () # self.server.serve_forever() else : print ( \"OSC server already exists\" )","title":"create_server()"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.kwargs","text":"decorate a function as an kwargs-style OSC handler. the decorated function should look like: def f(route, my_key=my_value, ...): ... the incoming OSC message should alternate argument names with values: /osc/route 'my_key' value 'my_key2' value ... Parameters: Name Type Description Default route specify the OSC route. if None, use the function name None json_keys names of keyword arguments which should be decoded from JSON to python objects, in the case that they arrive as strings. alternatively, if a string starts with '%JSON:' it will be decoded. None Source code in src/iipyper/osc.py 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def kwargs ( self , route = None , return_host = None , return_port = None , json_keys = None ): \"\"\"decorate a function as an kwargs-style OSC handler. the decorated function should look like: def f(route, my_key=my_value, ...): ... the incoming OSC message should alternate argument names with values: /osc/route 'my_key' value 'my_key2' value ... Args: route: specify the OSC route. if None, use the function name json_keys: names of keyword arguments which should be decoded from JSON to python objects, in the case that they arrive as strings. alternatively, if a string starts with '%JSON:' it will be decoded. \"\"\" return self . _decorate ( True , route , return_host , return_port , json_keys )","title":"kwargs()"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.send","text":"Send message to default client, or with client in address Parameters: Name Type Description Default address '/my/osc/route' or 'host:port/my/osc/route' required *msg content () client name of client or None None Source code in src/iipyper/osc.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 def send ( self , route , * msg , client = None ): \"\"\" Send message to default client, or with client in address Args: address: '/my/osc/route' or 'host:port/my/osc/route' *msg: content client: name of client or None \"\"\" if client is not None : client = self . get_client_by_name ( client ) elif ':' in route : try : client_str , route = route . split ( '/' , 1 ) assert ':' in client_str host , port = client_str . split ( ':' ) assert '/' not in host port = int ( port ) client = self . get_client_by_sender (( host , port )) except Exception : print ( f 'failed to get client address from OSC route \" { route } \"' ) else : client = next ( iter ( self . clients . values ())) if client is None : print ( f 'OSC message failed to send, could not determine client' ) return if not route . startswith ( '/' ): route = '/' + route client . send_message ( route , msg ) if self . verbose : print ( f \"OSC message sent { route } : { msg } \" )","title":"send()"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCReceiveListUpdater","text":"Bases: ReceiveListUpdater ReceiveListUpdater with an OSC handler Source code in src/iipyper/osc.py 391 392 393 394 395 396 397 398 399 400 401 402 403 class OSCReceiveListUpdater ( ReceiveListUpdater ): ''' ReceiveListUpdater with an OSC handler ''' def __init__ ( self , osc , address : str , f , state = None , count = 10 , update = False ): super () . __init__ ( f , state , count , update ) self . osc = osc self . address = address osc . add_handler ( self . address , self . receive ) def receive ( self , address , * args ): self . set ( list ( args [ 1 :]))","title":"OSCReceiveListUpdater"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCReceiveUpdater","text":"Bases: ReceiveUpdater ReceiveUpdater with an OSC handler Source code in src/iipyper/osc.py 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 class OSCReceiveUpdater ( ReceiveUpdater ): ''' ReceiveUpdater with an OSC handler ''' def __init__ ( self , osc , address : str , f , state = None , count = 10 , update = False ): super () . __init__ ( f , state , count , update ) self . osc = osc self . address = address osc . add_handler ( self . address , self . receive ) def receive ( self , address , * args ): # FIXME: ip:port/args ''' v: first argument to the handler is the IP:port of the sender v: or you can use dispatcher.map directly and not set needs_reply_address=True j: can I get ip:port from osc itself? v: if you know the sender ahead of time yeah, but that lets you respond to different senders dynamically ''' self . set ( args [ 1 :])","title":"OSCReceiveUpdater"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCReceiveUpdater.receive","text":"v: first argument to the handler is the IP:port of the sender v: or you can use dispatcher.map directly and not set needs_reply_address=True j: can I get ip:port from osc itself? v: if you know the sender ahead of time yeah, but that lets you respond to different senders dynamically Source code in src/iipyper/osc.py 379 380 381 382 383 384 385 386 387 388 389 def receive ( self , address , * args ): # FIXME: ip:port/args ''' v: first argument to the handler is the IP:port of the sender v: or you can use dispatcher.map directly and not set needs_reply_address=True j: can I get ip:port from osc itself? v: if you know the sender ahead of time yeah, but that lets you respond to different senders dynamically ''' self . set ( args [ 1 :])","title":"receive()"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCReceiveUpdaters","text":"o = OSCReceiveUpdaters(osc, {\"/tolvera/particles/pos\": s.osc_set_pos, \"/tolvera/particles/vel\": s.osc_set_vel}) Source code in src/iipyper/osc.py 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 class OSCReceiveUpdaters : ''' o = OSCReceiveUpdaters(osc, {\"/tolvera/particles/pos\": s.osc_set_pos, \"/tolvera/particles/vel\": s.osc_set_vel}) ''' def __init__ ( self , osc , receives = None , count = 10 ): self . osc = osc self . receives = [] self . count = count if receives is not None : self . add_dict ( receives , count = self . count ) def add_dict ( self , receives , count = None ): if count is None : count = self . count { a : self . add ( a , f , count = count ) for a , f in receives . items ()} def add ( self , address , function , state = None , count = None , update = False ): if count is None : count = self . count self . receives . append ( OSCReceiveUpdater ( self . osc , address , function , state , count , update )) def __call__ ( self ): [ r () for r in self . receives ]","title":"OSCReceiveUpdaters"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCSend","text":"Non rate-limited OSC send Source code in src/iipyper/osc.py 406 407 408 409 410 411 412 413 414 415 416 417 class OSCSend (): ''' Non rate-limited OSC send ''' def __init__ ( self , osc , address : str , f , count = 30 , client = None ): self . osc = osc self . address = address self . f = f self . client = client def __call__ ( self , * args ): self . osc . send ( self . address , * self . f ( * args ), client = self . client )","title":"OSCSend"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCSendUpdater","text":"Rate-limited OSC send Source code in src/iipyper/osc.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 class OSCSendUpdater (): ''' Rate-limited OSC send ''' def __init__ ( self , osc , address : str , f , count = 30 , client = None ): self . osc = osc self . address = address self . f = f self . count = count self . counter = 0 self . client = client def __call__ ( self ): self . counter += 1 if self . counter >= self . count : self . osc . send ( self . address , * self . f (), client = self . client ) self . counter = 0","title":"OSCSendUpdater"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCSendUpdaters","text":"o = OSCSendUpdaters(osc, client=\"particles\", count=10, sends={ \"/tolvera/particles/get/pos/all\": s.osc_get_pos_all }) Source code in src/iipyper/osc.py 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 class OSCSendUpdaters : ''' o = OSCSendUpdaters(osc, client=\"particles\", count=10, sends={ \"/tolvera/particles/get/pos/all\": s.osc_get_pos_all }) ''' def __init__ ( self , osc , sends = None , count = 10 , client = None ): self . osc = osc self . sends = [] self . count = count self . client = client if sends is not None : self . add_dict ( sends , self . count , self . client ) def add_dict ( self , sends , count = None , client = None ): if count is None : count = self . count if client is None : client = self . client { a : self . add ( a , f , count = count , client = client ) for a , f in sends . items ()} def add ( self , address , function , state = None , count = None , update = False , client = None ): if count is None : count = self . count if client is None : client = self . client self . sends . append ( OSCSendUpdater ( self . osc , address , function , count , client )) def __call__ ( self ): [ s () for s in self . sends ]","title":"OSCSendUpdaters"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCUpdaters","text":"o = OSCUpdaters(osc, client=\"boids\", count=10, receives={ \"/tolvera/boids/pos\": b.osc_set_pos, \"/tolvera/boids/vel\": b.osc_set_vel }, sends={ \"/tolvera/boids/pos/all\": b.osc_get_all_pos } ) Source code in src/iipyper/osc.py 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 class OSCUpdaters : ''' o = OSCUpdaters(osc, client=\"boids\", count=10, receives={ \"/tolvera/boids/pos\": b.osc_set_pos, \"/tolvera/boids/vel\": b.osc_set_vel }, sends={ \"/tolvera/boids/pos/all\": b.osc_get_all_pos } ) ''' def __init__ ( self , osc , sends = None , receives = None , send_count = 60 , receive_count = 10 , client = None ): self . osc = osc self . client = client self . send_count = send_count self . receive_count = receive_count self . sends = OSCSendUpdaters ( self . osc , count = self . send_count , client = self . client ) self . receives = OSCReceiveUpdaters ( self . osc , count = self . receive_count ) if sends is not None : self . add_sends ( sends ) if receives is not None : self . add_receives ( receives ) def add_sends ( self , sends , count = None , client = None ): if count is None : count = self . send_count if client is None : client = self . client self . sends . add_dict ( sends , count , client ) def add_send ( self , send , count = None , client = None ): if count is None : count = self . send_count if client is None : client = self . client self . sends . add ( send , client = client , count = count ) def add_receives ( self , receives , count = None ): if count is None : count = self . receive_count self . receives . add_dict ( receives , count = count ) def add_receive ( self , receive , count = None ): if count is None : count = self . receive_count self . receives . add ( receive , count = count ) def __call__ ( self ): self . sends () self . receives ()","title":"OSCUpdaters"},{"location":"reference/iipyper/osc/#iipyper.osc.ReceiveListUpdater","text":"Decouples event handling from updating Updating is rate-limited by a counter Assumes a list[float] instead of *args Source code in src/iipyper/osc.py 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 class ReceiveListUpdater : ''' Decouples event handling from updating Updating is rate-limited by a counter Assumes a list[float] instead of *args ''' def __init__ ( self , f , state = None , count = 5 , update = False ): self . f = f self . count = count self . counter = 0 self . update = update self . state = state def set ( self , state ): ''' Set the Updater's state ''' self . state = state self . update = True def __call__ ( self ): ''' Update the target function with internal state ''' self . counter += 1 if not ( self . update and self . counter > self . count and self . state is not None ): return self . f ( self . state ) self . counter = 0 self . update = False","title":"ReceiveListUpdater"},{"location":"reference/iipyper/osc/#iipyper.osc.ReceiveListUpdater.__call__","text":"Update the target function with internal state Source code in src/iipyper/osc.py 355 356 357 358 359 360 361 362 363 364 365 366 def __call__ ( self ): ''' Update the target function with internal state ''' self . counter += 1 if not ( self . update and self . counter > self . count and self . state is not None ): return self . f ( self . state ) self . counter = 0 self . update = False","title":"__call__()"},{"location":"reference/iipyper/osc/#iipyper.osc.ReceiveListUpdater.set","text":"Set the Updater's state Source code in src/iipyper/osc.py 348 349 350 351 352 353 def set ( self , state ): ''' Set the Updater's state ''' self . state = state self . update = True","title":"set()"},{"location":"reference/iipyper/osc/#iipyper.osc.ReceiveUpdater","text":"Decouples event handling from updating Updating is rate-limited by a counter Source code in src/iipyper/osc.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 class ReceiveUpdater : ''' Decouples event handling from updating Updating is rate-limited by a counter ''' def __init__ ( self , f , state = None , count = 5 , update = False ): self . f = f self . count = count self . counter = 0 self . update = update self . state = state def set ( self , state ): ''' Set the Updater's state ''' self . state = state self . update = True def __call__ ( self ): ''' Update the target function with internal state ''' self . counter += 1 if not ( self . update and self . counter > self . count and self . state is not None ): return self . f ( * self . state ) self . counter = 0 self . update = False","title":"ReceiveUpdater"},{"location":"reference/iipyper/osc/#iipyper.osc.ReceiveUpdater.__call__","text":"Update the target function with internal state Source code in src/iipyper/osc.py 321 322 323 324 325 326 327 328 329 330 331 332 def __call__ ( self ): ''' Update the target function with internal state ''' self . counter += 1 if not ( self . update and self . counter > self . count and self . state is not None ): return self . f ( * self . state ) self . counter = 0 self . update = False","title":"__call__()"},{"location":"reference/iipyper/osc/#iipyper.osc.ReceiveUpdater.set","text":"Set the Updater's state Source code in src/iipyper/osc.py 314 315 316 317 318 319 def set ( self , state ): ''' Set the Updater's state ''' self . state = state self . update = True","title":"set()"},{"location":"reference/iipyper/osc/#iipyper.osc.Updater","text":"Rate-limited function call Source code in src/iipyper/osc.py 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 class Updater (): ''' Rate-limited function call ''' def __init__ ( self , f , count = 30 ): self . f = f self . count = count self . counter = 0 def __call__ ( self ): self . counter += 1 if self . counter >= self . count : self . f () self . counter = 0","title":"Updater"},{"location":"reference/iipyper/state/","text":"","title":"State"},{"location":"reference/iipyper/tui/","text":"","title":"Tui"}]}