{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"iipyper","text":""},{"location":"#iipyper","title":"iipyper","text":"<p><code>iipyper</code> is a Python package for fast creation of Open Sound Control (OSC) and MIDI-based event loops.</p> <p>It is designed for creatives who want to explore the Python ecosystem and experiment with music and, for example, machine learning.</p> <p>For examples and tutorials of how to use <code>iipyper</code>, see our examples repo (TBC).</p> <p><code>iipyper</code> is developed by the Intelligent Instruments Lab. Connect us via the links at the bottom of this page.</p>"},{"location":"#install","title":"Install","text":"<p><code>iipyper</code> can be installed via PyPI:</p> <pre><code>pip install iipyper\n</code></pre>"},{"location":"#develop","title":"Develop","text":"<pre><code>git clone git@github.com:Intelligent-Instruments-Lab/iipyper.git\npip install -e iipyper\n</code></pre>"},{"location":"reference/iipyper/__init__/","title":"init","text":""},{"location":"reference/iipyper/__init__/#iipyper.cleanup","title":"<code>cleanup(f=None)</code>","text":"<p>@cleanup decorator</p> Source code in <code>src/iipyper/__init__.py</code> <pre><code>def cleanup(f=None):\n    \"\"\"@cleanup decorator\"\"\"\n    def decorator(f):\n        _cleanup_fns.append(f)\n        return f\n\n    if f is None: # return a decorator\n        return decorator\n    else: #bare decorator case; return decorated function\n        return decorator(f)\n</code></pre>"},{"location":"reference/iipyper/__init__/#iipyper.lock","title":"<code>lock(f)</code>","text":"<p>wrap the decorated function with the global iipyper lock</p> Source code in <code>src/iipyper/__init__.py</code> <pre><code>def lock(f):\n    \"\"\"wrap the decorated function with the global iipyper lock\"\"\"\n    def decorated(*a, **kw):\n        with _lock:\n            f(*a, **kw)\n    return decorated\n</code></pre>"},{"location":"reference/iipyper/__init__/#iipyper.repeat","title":"<code>repeat(interval=None, between_calls=False, lock=True, tick=0.005)</code>","text":"<p>@repeat decorator</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <p>time in seconds to repeat at. If the decorated function returns a number, use that as the interval to the next call</p> <code>None</code> <code>between_calls</code> <p>if True, interval is between call and next call, if False, between return and next call</p> <code>False</code> <code>lock</code> <p>if True, use the global iipyper lock to make calls thread-safe</p> <code>True</code> Source code in <code>src/iipyper/__init__.py</code> <pre><code>def repeat(interval=None, between_calls=False, lock=True, tick=5e-3):\n    \"\"\"@repeat decorator\n\n    Args:\n        interval: time in seconds to repeat at.\n            If the decorated function returns a number, use that as the interval\n            to the next call\n        between_calls: if True, interval is between call and next call,\n            if False, between return and next call\n        lock: if True, use the global iipyper lock to make calls thread-safe\n    \"\"\"\n    # close the decorator over interval and lock arguments\n    def decorator(f):\n        def g():\n            # clock = Clock(tick)\n            while True:\n                t = time.perf_counter()\n                returned_interval = maybe_lock(f, lock)\n\n                if isinstance(returned_interval, Number):\n                    wait_interval = returned_interval\n                else:\n                    wait_interval = interval\n\n                # replace False or None with 0\n                wait_interval = wait_interval or 0\n\n                if between_calls:\n                    # interval is between calls to the decorated function\n                    elapsed = time.perf_counter() - t\n                    wait = wait_interval - elapsed\n                else:\n                    t = time.perf_counter()\n                    wait = wait_interval\n                # else interval is between return of one and call and next call\n                # print(f'{wait=}')\n                # tt = time.perf_counter()\n                if wait &gt; 0:\n                    sleep = wait - tick\n                    if sleep &gt; 0:\n                        time.sleep(sleep)\n                    spin_end = t + wait_interval\n                    while time.perf_counter() &lt; spin_end: pass\n                    # print(f'waited = {time.perf_counter() - tt}')\n                else:\n                    print(\n                        f'@repeat function \"{f.__name__}\" is late by {-wait}')\n\n        th = Thread(target=g, daemon=True)\n        th.start()\n        _threads.append(th)\n\n    return decorator\n</code></pre>"},{"location":"reference/iipyper/__init__/#iipyper.run","title":"<code>run(main=None)</code>","text":"<p>call this on your main function to run it as an iipyper app</p> Source code in <code>src/iipyper/__init__.py</code> <pre><code>def run(main=None):\n    \"\"\"call this on your main function to run it as an iipyper app\"\"\"\n    try:\n        if main is not None:\n            fire.Fire(main)\n\n        # non-blocking main case:\n        start_audio()\n\n        # enter a loop if there is not one in main\n        while True:\n            time.sleep(3e-2)\n\n    except KeyboardInterrupt:\n        # for th in _threads:\n            # pass\n        for a in Audio.instances:\n            a.stream.stop()\n            a.stream.close()\n        for f in _cleanup_fns:\n            f()\n        exit(0)\n</code></pre>"},{"location":"reference/iipyper/__init__/#iipyper.start_audio","title":"<code>start_audio()</code>","text":"<p>start all audio streams</p> Source code in <code>src/iipyper/__init__.py</code> <pre><code>def start_audio():\n    \"\"\"start all audio streams\"\"\"\n    for a in Audio.instances:\n        if not a.stream.active:\n            a.stream.start()\n</code></pre>"},{"location":"reference/iipyper/audio/","title":"Audio","text":""},{"location":"reference/iipyper/midi/","title":"Midi","text":""},{"location":"reference/iipyper/midi/#iipyper.midi.MIDI","title":"<code>MIDI</code>","text":"Source code in <code>src/iipyper/midi.py</code> <pre><code>class MIDI:\n    \"\"\"\"\"\"\n    @classmethod\n    def print_ports(cls):\n        print('Available MIDI inputs:')\n        for s in set(mido.get_input_names()):\n            print(f'\\t{s}')\n        print('Available MIDI outputs:')\n        for s in set(mido.get_output_names()):\n            print(f'\\t{s}')\n        MIDI.ports_printed = True\n\n    ports_printed = False\n\n    def __init__(self, in_ports=None, out_ports=None, \n                 virtual_in_ports=1, virtual_out_ports=1, \n                 verbose=1, sleep_time=5e-4):\n        \"\"\"\n        Args:\n            in_ports: list of input devices to open (uses all by default)\n            out_ports: list of output devices to open (uses none by default)\n            virtual_in_ports: number of 'To iipyper X' ports to create\n            virtual_out_ports: number of 'From iipyper X' ports to create\n        \"\"\"\n        if not MIDI.ports_printed and verbose:\n            MIDI.print_ports()\n\n        self.running = False\n\n        self.verbose = int(verbose)\n        self.sleep_time = sleep_time\n        # type -&gt; list[Optional[set[port], Optional[set[channel]], function]\n        self.handlers = []\n\n        if isinstance(in_ports, str):\n            in_ports = in_ports.split(',')\n        if isinstance(out_ports, str):\n            out_ports = out_ports.split(',')\n\n        # TODO: fuzzy match port names\n\n        if in_ports is None or len(in_ports)==0:\n            in_ports = set(mido.get_input_names())\n\n        self.in_ports = {}  \n        for i in range(virtual_in_ports):\n            virtual_in = f'To iipyper {i+1}'\n            self.in_ports[virtual_in] = mido.open_input(\n                virtual_in, virtual=True)\n        for port in in_ports:\n            try:\n                self.in_ports[port] = mido.open_input(\n                    port, callback=self.get_callback(port))\n            except Exception:\n                print(f\"\"\"WARNING: MIDI input {port} not found\"\"\")\n\n        if self.verbose:\n            print(f\"\"\"opened MIDI input ports: {list(self.in_ports)}\"\"\")\n\n        ##### WIP\n        self.out_ports = {}\n        for i in range(virtual_out_ports):\n            virtual_out = f'From iipyper {i+1}'\n            self.out_ports[virtual_out] = mido.open_output(\n                virtual_out, virtual=True)\n\n        if out_ports is None:\n            out_ports = []\n        # if out_ports is None or len(out_ports)==0:\n            # out_ports = set(mido.get_output_names())  \n        # self.out_ports = {}\n        for port in out_ports:\n            try:\n                self.out_ports[port] = mido.open_output(port)\n            except Exception:\n                print(f\"\"\"WARNING: MIDI output {port} not found\"\"\")\n\n        if self.verbose:\n            print(f\"\"\"opened MIDI output ports: {list(self.out_ports)}\"\"\")\n\n        self.start()\n\n    def start(self):\n        self.running = True\n\n    def handle(self, *a, **kw):\n        \"\"\"MIDI handler decorator\n\n        Decorated function receives args:\n            msg: mido message\n        \"\"\"\n        if len(a):\n            # bare decorator\n            assert len(a)==1\n            assert len(kw)==0\n            assert hasattr(a[0], '__call__')\n            f = a[0]\n            filters = {}\n        else:\n            # with filter arguments\n            for k in kw:\n                assert k in {\n                    'channel', 'port', 'type', \n                    'note', 'velocity', 'value', \n                    'control', 'program'\n                    }, f'unknown MIDI message filter \"{k}\"'\n            filters = {k:_get_filter(v) for k,v in kw.items()}\n            f = None\n\n        def decorator(f):\n            self.handlers.append((filters, f))\n            return f\n\n        return decorator if f is None else decorator(f)\n\n    def get_callback(self, port_name):\n        # print(port_name)\n        def callback(msg):\n            if self.verbose &gt; 1:\n                print(f'{msg=}')\n            if not self.running:\n                return\n            for filters, f in self.handlers:\n                use_handler = (\n                    'port' not in filters \n                    or port_name in filters.pop('port'))\n                use_handler &amp;= all(\n                    filt is None \n                    or not hasattr(msg, k)\n                    or getattr(msg, k) in filt\n                    for k,filt in filters.items())\n                if use_handler:\n                    with _lock:\n                        print(port_name)\n                        f(msg)\n        return callback\n\n    def _send_msg(self, port, m):\n        \"\"\"send on a specific port or all output ports\"\"\"\n        ports = self.out_ports.values() if port is None else [self.out_ports[port]]\n        # print(ports)\n        for p in ports:\n            # print('iipyper send', m)\n            # iiuc mido send should already be thread safe\n            # with _lock:\n            p.send(m)\n\n    # # see https://mido.readthedocs.io/en/latest/message_types.html\n\n    def send(self, m, *a, port=None, **kw):\n        \"\"\"send a mido message\"\"\"\n        # print(f'SEND {time.perf_counter()}')\n        if isinstance(m, mido.Message):\n            self._send_msg(port, m)\n            if len(a)+len(kw) &gt; 0:\n                print('warning: extra arguments to MIDI send')\n        elif isinstance(m, str):\n            try:\n                self._send_msg(port, mido.Message(m, *a, **kw))\n            except Exception:\n                print('MIDI send failed: bad arguments to mido.Message')\n                raise\n        else:\n            print('MIDI send failed: first argument should be a mido.Message or str')\n\n    def __getattr__(self, name):\n        if name=='cc': name = 'control_change'\n        if name=='pc': name = 'program_change'\n        if name in (\n            'note_on', 'note_off', 'polytouch', 'control_change', \n            'program_change', 'aftertouch', 'pitchwheel', 'sysex'):\n            return lambda *a, **kw: self.send(name, *a, **kw)\n        raise AttributeError\n</code></pre>"},{"location":"reference/iipyper/midi/#iipyper.midi.MIDI.__init__","title":"<code>__init__(in_ports=None, out_ports=None, virtual_in_ports=1, virtual_out_ports=1, verbose=1, sleep_time=0.0005)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>in_ports</code> <p>list of input devices to open (uses all by default)</p> <code>None</code> <code>out_ports</code> <p>list of output devices to open (uses none by default)</p> <code>None</code> <code>virtual_in_ports</code> <p>number of 'To iipyper X' ports to create</p> <code>1</code> <code>virtual_out_ports</code> <p>number of 'From iipyper X' ports to create</p> <code>1</code> Source code in <code>src/iipyper/midi.py</code> <pre><code>def __init__(self, in_ports=None, out_ports=None, \n             virtual_in_ports=1, virtual_out_ports=1, \n             verbose=1, sleep_time=5e-4):\n    \"\"\"\n    Args:\n        in_ports: list of input devices to open (uses all by default)\n        out_ports: list of output devices to open (uses none by default)\n        virtual_in_ports: number of 'To iipyper X' ports to create\n        virtual_out_ports: number of 'From iipyper X' ports to create\n    \"\"\"\n    if not MIDI.ports_printed and verbose:\n        MIDI.print_ports()\n\n    self.running = False\n\n    self.verbose = int(verbose)\n    self.sleep_time = sleep_time\n    # type -&gt; list[Optional[set[port], Optional[set[channel]], function]\n    self.handlers = []\n\n    if isinstance(in_ports, str):\n        in_ports = in_ports.split(',')\n    if isinstance(out_ports, str):\n        out_ports = out_ports.split(',')\n\n    # TODO: fuzzy match port names\n\n    if in_ports is None or len(in_ports)==0:\n        in_ports = set(mido.get_input_names())\n\n    self.in_ports = {}  \n    for i in range(virtual_in_ports):\n        virtual_in = f'To iipyper {i+1}'\n        self.in_ports[virtual_in] = mido.open_input(\n            virtual_in, virtual=True)\n    for port in in_ports:\n        try:\n            self.in_ports[port] = mido.open_input(\n                port, callback=self.get_callback(port))\n        except Exception:\n            print(f\"\"\"WARNING: MIDI input {port} not found\"\"\")\n\n    if self.verbose:\n        print(f\"\"\"opened MIDI input ports: {list(self.in_ports)}\"\"\")\n\n    ##### WIP\n    self.out_ports = {}\n    for i in range(virtual_out_ports):\n        virtual_out = f'From iipyper {i+1}'\n        self.out_ports[virtual_out] = mido.open_output(\n            virtual_out, virtual=True)\n\n    if out_ports is None:\n        out_ports = []\n    # if out_ports is None or len(out_ports)==0:\n        # out_ports = set(mido.get_output_names())  \n    # self.out_ports = {}\n    for port in out_ports:\n        try:\n            self.out_ports[port] = mido.open_output(port)\n        except Exception:\n            print(f\"\"\"WARNING: MIDI output {port} not found\"\"\")\n\n    if self.verbose:\n        print(f\"\"\"opened MIDI output ports: {list(self.out_ports)}\"\"\")\n\n    self.start()\n</code></pre>"},{"location":"reference/iipyper/midi/#iipyper.midi.MIDI.handle","title":"<code>handle(*a, **kw)</code>","text":"<p>MIDI handler decorator</p> Decorated function receives args <p>msg: mido message</p> Source code in <code>src/iipyper/midi.py</code> <pre><code>def handle(self, *a, **kw):\n    \"\"\"MIDI handler decorator\n\n    Decorated function receives args:\n        msg: mido message\n    \"\"\"\n    if len(a):\n        # bare decorator\n        assert len(a)==1\n        assert len(kw)==0\n        assert hasattr(a[0], '__call__')\n        f = a[0]\n        filters = {}\n    else:\n        # with filter arguments\n        for k in kw:\n            assert k in {\n                'channel', 'port', 'type', \n                'note', 'velocity', 'value', \n                'control', 'program'\n                }, f'unknown MIDI message filter \"{k}\"'\n        filters = {k:_get_filter(v) for k,v in kw.items()}\n        f = None\n\n    def decorator(f):\n        self.handlers.append((filters, f))\n        return f\n\n    return decorator if f is None else decorator(f)\n</code></pre>"},{"location":"reference/iipyper/midi/#iipyper.midi.MIDI.send","title":"<code>send(m, *a, port=None, **kw)</code>","text":"<p>send a mido message</p> Source code in <code>src/iipyper/midi.py</code> <pre><code>def send(self, m, *a, port=None, **kw):\n    \"\"\"send a mido message\"\"\"\n    # print(f'SEND {time.perf_counter()}')\n    if isinstance(m, mido.Message):\n        self._send_msg(port, m)\n        if len(a)+len(kw) &gt; 0:\n            print('warning: extra arguments to MIDI send')\n    elif isinstance(m, str):\n        try:\n            self._send_msg(port, mido.Message(m, *a, **kw))\n        except Exception:\n            print('MIDI send failed: bad arguments to mido.Message')\n            raise\n    else:\n        print('MIDI send failed: first argument should be a mido.Message or str')\n</code></pre>"},{"location":"reference/iipyper/osc/","title":"Osc","text":""},{"location":"reference/iipyper/osc/#iipyper.osc.OSC","title":"<code>OSC</code>","text":"<p>TODO: Handshake between server and clients TODO: Polling clients after handshake TODO: Enqueuing and buffering messages (?)</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>class OSC():\n    \"\"\"\n    TODO: Handshake between server and clients\n    TODO: Polling clients after handshake\n    TODO: Enqueuing and buffering messages (?)\n    \"\"\"\n    def __init__(self, host=\"127.0.0.1\", port=9999, verbose=True,\n         concurrent=False):\n        \"\"\"\n        TODO: Expand to support multiple IPs + ports\n\n        Args:\n            host (str): IP address\n            port (int): port to receive on\n            verbose (bool): whether to print activity\n            concurrent (bool): if True, handle each incoming OSC message on \n                its own thread. otherwise, incoming OSC is handled serially on \n                one thread for the whole OSC object.\n        \"\"\"\n        self.verbose = verbose\n        self.concurrent = concurrent\n        self.host = host\n        self.port = port\n        self.dispatcher = Dispatcher()\n        self.server = None\n        self.clients = {} # (host,port) -&gt; client\n        self.client_names = {} # (name) -&gt; (host,port)\n\n        self.create_server()\n\n    def create_server(self):#, host=None, port=None):\n        \"\"\"\n        Create the server\n        \"\"\"\n        # if (host is None):\n        #     host = self.host\n        # if (port is None):\n        #     port = self.port\n        cls = ThreadingOSCUDPServer if self.concurrent else BlockingOSCUDPServer\n\n        if (self.server is None):\n            self.server = cls((self.host, self.port), self.dispatcher)\n            if self.verbose:\n                print(f\"OSC server created {self.host}:{self.port}\")\n\n            # start the OSC server on its own thread\n            Thread(target=self.server.serve_forever, daemon=True).start()\n            # self.server.serve_forever()\n        else:\n            print(\"OSC server already exists\")\n\n    # def close_server(self):\n    #     \"\"\"\n    #     Close the server\n    #     \"\"\"\n    #     if (self.server is not None):\n    #         self.transport.close()\n    #     else:\n    #         print(\"OSC server does not exist\")\n\n    def add_handler(self, address, handler):\n        \"\"\"\n        Map the custom message handler to the OSC dispatcher\n        \"\"\"\n        # if (self.server is not None):\n        self.dispatcher.map(address, handler, needs_reply_address=True)\n\n    def create_client(self, name, host=None, port=None):\n        \"\"\"\n        Add an OSC client.\n        Args:\n            name: name this client\n            host (int): IP to send to, defaults to same as server\n            port (int): port to send to, defaults to 57120 (supercollider)\n        \"\"\"\n        if (host == None):\n            host = self.host\n        if (port == None):\n            port = 57120\n        if ((host, port) not in self.clients):\n            self.clients[host, port] = SimpleUDPClient(host, port)\n            if self.verbose:\n                print(f\"OSC client created {host}:{port}\")\n        else:\n            print(\"OSC client already exists\")\n        self.client_names[name] = (host, port)\n\n    def get_client_by_name(self, name):\n        try:\n            return self.clients[self.client_names[name]]\n        except Exception:\n            print(f'no client with name \"{name}\"')\n            return None\n\n    def get_client_by_sender(self, address):\n        if address not in self.clients:\n            host, port = address\n            self.create_client(f'{host}:{port}', host, port)\n        return self.clients[address]\n\n    def send(self, route, *msg, client=None):\n        \"\"\"\n        Send message to default client, or with client in address\n\n        Args:\n            address: '/my/osc/route' or 'host:port/my/osc/route'\n            *msg: content\n            client: name of client or None\n        \"\"\"\n        if client is not None:\n            client = self.get_client_by_name(client)\n        elif ':' in route:\n            try:\n                client_str, route = route.split('/', 1)\n                assert ':' in client_str\n                host, port = client_str.split(':')\n                assert '/' not in host\n                port = int(port)\n                client = self.get_client_by_sender((host, port))\n            except Exception:\n                print(f'failed to get client address from OSC route \"{route}\"')\n        else:\n            client = next(iter(self.clients.values()))\n\n        if client is None:\n            print(f'OSC message failed to send, could not determine client')\n            return\n\n        if not route.startswith('/'):\n            route = '/'+route\n        client.send_message(route, msg)\n        if self.verbose:\n            print(f\"OSC message sent {route}:{msg}\")\n\n    def _decorate(self, use_kwargs, route, return_host, return_port, json_keys):\n        \"\"\"generic decorator (args and kwargs cases)\"\"\"\n        if hasattr(route, '__call__'):\n            # bare decorator\n            f = route\n            route = None\n            json_keys = set()\n        else:\n            f = None\n            json_keys = set(json_keys or [])\n\n        def decorator(f, route=route, \n                return_host=return_host, return_port=return_port, \n                json_keys=json_keys):\n            # default_route = f'/{f.__name__}/*'\n            if route is None:\n                route = f'/{f.__name__}'\n            # print(route)\n            assert isinstance(route, str) and route.startswith('/')\n\n            def handler(client, address, *args):\n                \"\"\"\n                Args:\n                    client: (host,port) of sender\n                    address: full OSC address\n                    *args: content of OSC message\n                \"\"\"\n                # print('handler:', client, address)\n                if use_kwargs:\n                    kwargs = {k:v for k,v in zip(args[::2], args[1::2])}\n                    # JSON conversions\n                    for k in kwargs: \n                        do_json(kwargs, k, json_keys, route)\n                    args = []\n                else:\n                    kwargs = {}\n\n                with _lock:\n                    r = f(address, *args, **kwargs)\n                # if there was a return value,\n                # send it as a message back to the sender\n                if r is not None:\n                    if not hasattr(r, '__len__'):\n                        print(\"\"\"\n                        value returned from OSC handler should start with route\n                        \"\"\")\n                    else:\n                        client = (\n                            client[0] if return_host is None else return_host,\n                            client[1] if return_port is None else return_port\n                        )\n                        print(client, r)\n                        self.get_client_by_sender(client).send_message(r[0], r[1:])\n\n            self.add_handler(route, handler)\n\n            return f\n\n        return decorator if f is None else decorator(f)\n\n    def args(self, route=None, return_host=None, return_port=None):\n        \"\"\"decorate a function as an args-style OSC handler.\n\n        the decorated function should look like:\n        def f(route, my_arg, my_arg2, ...):\n            ...\n        the OSC message will be converted to python types and passed as positional\n        arguments.\n        \"\"\"\n        return self._decorate(False, route, return_host, return_port, None)\n\n    def kwargs(self, route=None, return_host=None, return_port=None, json_keys=None):\n        \"\"\"decorate a function as an kwargs-style OSC handler.\n\n        the decorated function should look like:\n        def f(route, my_key=my_value, ...):\n            ...\n        the incoming OSC message should alternate argument names with values:\n            /osc/route 'my_key' value 'my_key2' value ...\n\n        Args:\n            route: specify the OSC route. if None, use the function name\n            json_keys: names of keyword arguments which should be decoded\n                from JSON to python objects, \n                in the case that they arrive as strings.\n                alternatively, if a string starts with '%JSON:' it will be decoded.\n        \"\"\"\n        return self._decorate(True, route, return_host, return_port, json_keys)\n\n    def __call__(self, client, *a, **kw):\n        \"\"\"alternate syntax for `send` with client name first\"\"\"\n        self.send(*a, client=client, **kw)\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.__call__","title":"<code>__call__(client, *a, **kw)</code>","text":"<p>alternate syntax for <code>send</code> with client name first</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def __call__(self, client, *a, **kw):\n    \"\"\"alternate syntax for `send` with client name first\"\"\"\n    self.send(*a, client=client, **kw)\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.__init__","title":"<code>__init__(host='127.0.0.1', port=9999, verbose=True, concurrent=False)</code>","text":"<p>TODO: Expand to support multiple IPs + ports</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>IP address</p> <code>'127.0.0.1'</code> <code>port</code> <code>int</code> <p>port to receive on</p> <code>9999</code> <code>verbose</code> <code>bool</code> <p>whether to print activity</p> <code>True</code> <code>concurrent</code> <code>bool</code> <p>if True, handle each incoming OSC message on  its own thread. otherwise, incoming OSC is handled serially on  one thread for the whole OSC object.</p> <code>False</code> Source code in <code>src/iipyper/osc.py</code> <pre><code>def __init__(self, host=\"127.0.0.1\", port=9999, verbose=True,\n     concurrent=False):\n    \"\"\"\n    TODO: Expand to support multiple IPs + ports\n\n    Args:\n        host (str): IP address\n        port (int): port to receive on\n        verbose (bool): whether to print activity\n        concurrent (bool): if True, handle each incoming OSC message on \n            its own thread. otherwise, incoming OSC is handled serially on \n            one thread for the whole OSC object.\n    \"\"\"\n    self.verbose = verbose\n    self.concurrent = concurrent\n    self.host = host\n    self.port = port\n    self.dispatcher = Dispatcher()\n    self.server = None\n    self.clients = {} # (host,port) -&gt; client\n    self.client_names = {} # (name) -&gt; (host,port)\n\n    self.create_server()\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.add_handler","title":"<code>add_handler(address, handler)</code>","text":"<p>Map the custom message handler to the OSC dispatcher</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def add_handler(self, address, handler):\n    \"\"\"\n    Map the custom message handler to the OSC dispatcher\n    \"\"\"\n    # if (self.server is not None):\n    self.dispatcher.map(address, handler, needs_reply_address=True)\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.args","title":"<code>args(route=None, return_host=None, return_port=None)</code>","text":"<p>decorate a function as an args-style OSC handler.</p> <p>the decorated function should look like: def f(route, my_arg, my_arg2, ...):     ... the OSC message will be converted to python types and passed as positional arguments.</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def args(self, route=None, return_host=None, return_port=None):\n    \"\"\"decorate a function as an args-style OSC handler.\n\n    the decorated function should look like:\n    def f(route, my_arg, my_arg2, ...):\n        ...\n    the OSC message will be converted to python types and passed as positional\n    arguments.\n    \"\"\"\n    return self._decorate(False, route, return_host, return_port, None)\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.create_client","title":"<code>create_client(name, host=None, port=None)</code>","text":"<p>Add an OSC client. Args:     name: name this client     host (int): IP to send to, defaults to same as server     port (int): port to send to, defaults to 57120 (supercollider)</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def create_client(self, name, host=None, port=None):\n    \"\"\"\n    Add an OSC client.\n    Args:\n        name: name this client\n        host (int): IP to send to, defaults to same as server\n        port (int): port to send to, defaults to 57120 (supercollider)\n    \"\"\"\n    if (host == None):\n        host = self.host\n    if (port == None):\n        port = 57120\n    if ((host, port) not in self.clients):\n        self.clients[host, port] = SimpleUDPClient(host, port)\n        if self.verbose:\n            print(f\"OSC client created {host}:{port}\")\n    else:\n        print(\"OSC client already exists\")\n    self.client_names[name] = (host, port)\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.create_server","title":"<code>create_server()</code>","text":"<p>Create the server</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def create_server(self):#, host=None, port=None):\n    \"\"\"\n    Create the server\n    \"\"\"\n    # if (host is None):\n    #     host = self.host\n    # if (port is None):\n    #     port = self.port\n    cls = ThreadingOSCUDPServer if self.concurrent else BlockingOSCUDPServer\n\n    if (self.server is None):\n        self.server = cls((self.host, self.port), self.dispatcher)\n        if self.verbose:\n            print(f\"OSC server created {self.host}:{self.port}\")\n\n        # start the OSC server on its own thread\n        Thread(target=self.server.serve_forever, daemon=True).start()\n        # self.server.serve_forever()\n    else:\n        print(\"OSC server already exists\")\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.kwargs","title":"<code>kwargs(route=None, return_host=None, return_port=None, json_keys=None)</code>","text":"<p>decorate a function as an kwargs-style OSC handler.</p> <p>the decorated function should look like: def f(route, my_key=my_value, ...):     ... the incoming OSC message should alternate argument names with values:     /osc/route 'my_key' value 'my_key2' value ...</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <p>specify the OSC route. if None, use the function name</p> <code>None</code> <code>json_keys</code> <p>names of keyword arguments which should be decoded from JSON to python objects,  in the case that they arrive as strings. alternatively, if a string starts with '%JSON:' it will be decoded.</p> <code>None</code> Source code in <code>src/iipyper/osc.py</code> <pre><code>def kwargs(self, route=None, return_host=None, return_port=None, json_keys=None):\n    \"\"\"decorate a function as an kwargs-style OSC handler.\n\n    the decorated function should look like:\n    def f(route, my_key=my_value, ...):\n        ...\n    the incoming OSC message should alternate argument names with values:\n        /osc/route 'my_key' value 'my_key2' value ...\n\n    Args:\n        route: specify the OSC route. if None, use the function name\n        json_keys: names of keyword arguments which should be decoded\n            from JSON to python objects, \n            in the case that they arrive as strings.\n            alternatively, if a string starts with '%JSON:' it will be decoded.\n    \"\"\"\n    return self._decorate(True, route, return_host, return_port, json_keys)\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.send","title":"<code>send(route, *msg, client=None)</code>","text":"<p>Send message to default client, or with client in address</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <p>'/my/osc/route' or 'host:port/my/osc/route'</p> required <code>*msg</code> <p>content</p> <code>()</code> <code>client</code> <p>name of client or None</p> <code>None</code> Source code in <code>src/iipyper/osc.py</code> <pre><code>def send(self, route, *msg, client=None):\n    \"\"\"\n    Send message to default client, or with client in address\n\n    Args:\n        address: '/my/osc/route' or 'host:port/my/osc/route'\n        *msg: content\n        client: name of client or None\n    \"\"\"\n    if client is not None:\n        client = self.get_client_by_name(client)\n    elif ':' in route:\n        try:\n            client_str, route = route.split('/', 1)\n            assert ':' in client_str\n            host, port = client_str.split(':')\n            assert '/' not in host\n            port = int(port)\n            client = self.get_client_by_sender((host, port))\n        except Exception:\n            print(f'failed to get client address from OSC route \"{route}\"')\n    else:\n        client = next(iter(self.clients.values()))\n\n    if client is None:\n        print(f'OSC message failed to send, could not determine client')\n        return\n\n    if not route.startswith('/'):\n        route = '/'+route\n    client.send_message(route, msg)\n    if self.verbose:\n        print(f\"OSC message sent {route}:{msg}\")\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCReceiveListUpdater","title":"<code>OSCReceiveListUpdater</code>","text":"<p>             Bases: <code>ReceiveListUpdater</code></p> <p>ReceiveListUpdater with an OSC handler</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>class OSCReceiveListUpdater(ReceiveListUpdater):\n    '''\n    ReceiveListUpdater with an OSC handler\n    '''\n\n    def __init__(self, osc, address: str, f, state=None, count=10, update=False):\n        super().__init__(f, state, count, update)\n        self.osc = osc\n        self.address = address\n        osc.add_handler(self.address, self.receive)\n\n    def receive(self, address, *args):\n        self.set(list(args[1:]))\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCReceiveUpdater","title":"<code>OSCReceiveUpdater</code>","text":"<p>             Bases: <code>ReceiveUpdater</code></p> <p>ReceiveUpdater with an OSC handler</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>class OSCReceiveUpdater(ReceiveUpdater):\n    '''\n    ReceiveUpdater with an OSC handler\n    '''\n\n    def __init__(self, osc, address: str, f, state=None, count=10, update=False):\n        super().__init__(f, state, count, update)\n        self.osc = osc\n        self.address = address\n        osc.add_handler(self.address, self.receive)\n\n    def receive(self, address, *args):\n        # FIXME: ip:port/args\n        '''\n        v: first argument to the handler is the IP:port of the sender\n        v: or you can use dispatcher.map directly\n           and not set needs_reply_address=True\n        j: can I get ip:port from osc itself?\n        v: if you know the sender ahead of time yeah,\n           but that lets you respond to different senders dynamically\n        '''\n        self.set(args[1:])\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCReceiveUpdater.receive","title":"<code>receive(address, *args)</code>","text":"<p>v: first argument to the handler is the IP:port of the sender v: or you can use dispatcher.map directly    and not set needs_reply_address=True j: can I get ip:port from osc itself? v: if you know the sender ahead of time yeah,    but that lets you respond to different senders dynamically</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def receive(self, address, *args):\n    # FIXME: ip:port/args\n    '''\n    v: first argument to the handler is the IP:port of the sender\n    v: or you can use dispatcher.map directly\n       and not set needs_reply_address=True\n    j: can I get ip:port from osc itself?\n    v: if you know the sender ahead of time yeah,\n       but that lets you respond to different senders dynamically\n    '''\n    self.set(args[1:])\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCReceiveUpdaters","title":"<code>OSCReceiveUpdaters</code>","text":"<p>o = OSCReceiveUpdaters(osc,     {\"/tolvera/particles/pos\": s.osc_set_pos,      \"/tolvera/particles/vel\": s.osc_set_vel})</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>class OSCReceiveUpdaters:\n    '''\n    o = OSCReceiveUpdaters(osc,\n        {\"/tolvera/particles/pos\": s.osc_set_pos,\n         \"/tolvera/particles/vel\": s.osc_set_vel})\n    '''\n\n    def __init__(self, osc, receives=None, count=10):\n        self.osc = osc\n        self.receives = []\n        self.count = count\n        if receives is not None:\n            self.add_dict(receives, count=self.count)\n\n    def add_dict(self, receives, count=None):\n        if count is None:\n            count = self.count\n        {a: self.add(a, f, count=count) for a, f in receives.items()}\n\n    def add(self, address, function, state=None, count=None, update=False):\n        if count is None:\n            count = self.count\n        self.receives.append(\n            OSCReceiveUpdater(self.osc, address, function,\n                              state, count, update))\n\n    def __call__(self):\n        [r() for r in self.receives]\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCSend","title":"<code>OSCSend</code>","text":"<p>Non rate-limited OSC send</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>class OSCSend():\n    '''\n    Non rate-limited OSC send\n    '''\n    def __init__(self, osc, address: str, f, count=30, client=None):\n        self.osc = osc\n        self.address = address\n        self.f = f\n        self.client = client\n\n    def __call__(self, *args):\n        self.osc.send(self.address, *self.f(*args), client=self.client)\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCSendUpdater","title":"<code>OSCSendUpdater</code>","text":"<p>Rate-limited OSC send</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>class OSCSendUpdater():\n    '''\n    Rate-limited OSC send\n    '''\n\n    def __init__(self, osc, address: str, f, count=30, client=None):\n        self.osc = osc\n        self.address = address\n        self.f = f\n        self.count = count\n        self.counter = 0\n        self.client = client\n\n    def __call__(self):\n        self.counter += 1\n        if self.counter &gt;= self.count:\n            self.osc.send(self.address, *self.f(), client=self.client)\n            self.counter = 0\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCSendUpdaters","title":"<code>OSCSendUpdaters</code>","text":"<p>o = OSCSendUpdaters(osc, client=\"particles\", count=10,     sends={         \"/tolvera/particles/get/pos/all\": s.osc_get_pos_all     })</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>class OSCSendUpdaters:\n    '''\n    o = OSCSendUpdaters(osc, client=\"particles\", count=10,\n        sends={\n            \"/tolvera/particles/get/pos/all\": s.osc_get_pos_all\n        })\n    '''\n\n    def __init__(self, osc, sends=None, count=10, client=None):\n        self.osc = osc\n        self.sends = []\n        self.count = count\n        self.client = client\n        if sends is not None:\n            self.add_dict(sends, self.count, self.client)\n\n    def add_dict(self, sends, count=None, client=None):\n        if count is None:\n            count = self.count\n        if client is None:\n            client = self.client\n        {a: self.add(a, f, count=count, client=client)\n                     for a, f in sends.items()}\n\n    def add(self, address, function, state=None, count=None, update=False, client=None):\n        if count is None:\n            count = self.count\n        if client is None:\n            client = self.client\n        self.sends.append(\n            OSCSendUpdater(self.osc, address, function, count, client))\n\n    def __call__(self):\n        [s() for s in self.sends]\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCUpdaters","title":"<code>OSCUpdaters</code>","text":"<p>o = OSCUpdaters(osc, client=\"boids\", count=10,     receives={         \"/tolvera/boids/pos\": b.osc_set_pos,         \"/tolvera/boids/vel\": b.osc_set_vel     },     sends={         \"/tolvera/boids/pos/all\": b.osc_get_all_pos     } )</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>class OSCUpdaters:\n    '''\n    o = OSCUpdaters(osc, client=\"boids\", count=10,\n        receives={\n            \"/tolvera/boids/pos\": b.osc_set_pos,\n            \"/tolvera/boids/vel\": b.osc_set_vel\n        },\n        sends={\n            \"/tolvera/boids/pos/all\": b.osc_get_all_pos\n        }\n    )\n    '''\n\n    def __init__(self, osc,\n                 sends=None, receives=None,\n                 send_count=60, receive_count=10,\n                 client=None):\n        self.osc = osc\n        self.client = client\n        self.send_count = send_count\n        self.receive_count = receive_count\n        self.sends = OSCSendUpdaters(\n            self.osc, count=self.send_count, client=self.client)\n        self.receives = OSCReceiveUpdaters(self.osc, count=self.receive_count)\n        if sends is not None:\n            self.add_sends(sends)\n        if receives is not None:\n            self.add_receives(receives)\n\n    def add_sends(self, sends, count=None, client=None):\n        if count is None:\n            count = self.send_count\n        if client is None:\n            client = self.client\n        self.sends.add_dict(sends, count, client)\n\n    def add_send(self, send, count=None, client=None):\n        if count is None:\n            count = self.send_count\n        if client is None:\n            client = self.client\n        self.sends.add(send, client=client, count=count)\n\n    def add_receives(self, receives, count=None):\n        if count is None:\n            count = self.receive_count\n        self.receives.add_dict(receives, count=count)\n\n    def add_receive(self, receive, count=None):\n        if count is None:\n            count = self.receive_count\n        self.receives.add(receive, count=count)\n\n    def __call__(self):\n        self.sends()\n        self.receives()\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.ReceiveListUpdater","title":"<code>ReceiveListUpdater</code>","text":"<p>Decouples event handling from updating Updating is rate-limited by a counter Assumes a list[float] instead of *args</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>class ReceiveListUpdater:\n    '''\n    Decouples event handling from updating\n    Updating is rate-limited by a counter\n    Assumes a list[float] instead of *args\n    '''\n\n    def __init__(self, f, state=None, count=5, update=False):\n        self.f = f\n        self.count = count\n        self.counter = 0\n        self.update = update\n        self.state = state\n\n    def set(self, state):\n        '''\n        Set the Updater's state\n        '''\n        self.state = state\n        self.update = True\n\n    def __call__(self):\n        '''\n        Update the target function with internal state\n        '''\n        self.counter += 1\n        if not (self.update and\n                self.counter &gt; self.count and\n                self.state is not None):\n            return\n        self.f(self.state)\n        self.counter = 0\n        self.update = False\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.ReceiveListUpdater.__call__","title":"<code>__call__()</code>","text":"<p>Update the target function with internal state</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def __call__(self):\n    '''\n    Update the target function with internal state\n    '''\n    self.counter += 1\n    if not (self.update and\n            self.counter &gt; self.count and\n            self.state is not None):\n        return\n    self.f(self.state)\n    self.counter = 0\n    self.update = False\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.ReceiveListUpdater.set","title":"<code>set(state)</code>","text":"<p>Set the Updater's state</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def set(self, state):\n    '''\n    Set the Updater's state\n    '''\n    self.state = state\n    self.update = True\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.ReceiveUpdater","title":"<code>ReceiveUpdater</code>","text":"<p>Decouples event handling from updating Updating is rate-limited by a counter</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>class ReceiveUpdater:\n    '''\n    Decouples event handling from updating\n    Updating is rate-limited by a counter\n    '''\n\n    def __init__(self, f, state=None, count=5, update=False):\n        self.f = f\n        self.count = count\n        self.counter = 0\n        self.update = update\n        self.state = state\n\n    def set(self, state):\n        '''\n        Set the Updater's state\n        '''\n        self.state = state\n        self.update = True\n\n    def __call__(self):\n        '''\n        Update the target function with internal state\n        '''\n        self.counter += 1\n        if not (self.update and\n                self.counter &gt; self.count and\n                self.state is not None):\n            return\n        self.f(*self.state)\n        self.counter = 0\n        self.update = False\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.ReceiveUpdater.__call__","title":"<code>__call__()</code>","text":"<p>Update the target function with internal state</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def __call__(self):\n    '''\n    Update the target function with internal state\n    '''\n    self.counter += 1\n    if not (self.update and\n            self.counter &gt; self.count and\n            self.state is not None):\n        return\n    self.f(*self.state)\n    self.counter = 0\n    self.update = False\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.ReceiveUpdater.set","title":"<code>set(state)</code>","text":"<p>Set the Updater's state</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def set(self, state):\n    '''\n    Set the Updater's state\n    '''\n    self.state = state\n    self.update = True\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.Updater","title":"<code>Updater</code>","text":"<p>Rate-limited function call</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>class Updater():\n    '''\n    Rate-limited function call\n    '''\n\n    def __init__(self, f, count=30):\n        self.f = f\n        self.count = count\n        self.counter = 0\n\n    def __call__(self):\n        self.counter += 1\n        if self.counter &gt;= self.count:\n            self.f()\n            self.counter = 0\n</code></pre>"},{"location":"reference/iipyper/state/","title":"State","text":""},{"location":"reference/iipyper/timing/","title":"Timing","text":""},{"location":"reference/iipyper/timing/#iipyper.timing.Stopwatch","title":"<code>Stopwatch</code>","text":"Source code in <code>src/iipyper/timing.py</code> <pre><code>class Stopwatch:\n    def __init__(self, punch=True):\n        self.t = None\n        if punch:\n            self.punch()\n\n    def punch(self, latency=0):\n        \"\"\"return elapsed time since last punch, then punch\n\n        Args:\n            latency: punch `latency` seconds in the past, \n                unless it would be before the previous punch\n        \"\"\"\n        t = time.perf_counter_ns() - latency\n        if self.t is None:\n            dt_ns = 0\n        else:\n            t = max(self.t, t)\n            dt_ns = t - self.t\n        self.t = t\n        return dt_ns * 1e-9\n\n    def read(self):\n        \"\"\"return elapsed time since last punch\"\"\"\n        if self.t is None:\n            return self.punch()\n        return (time.perf_counter_ns() - self.t) * 1e-9\n</code></pre>"},{"location":"reference/iipyper/timing/#iipyper.timing.Stopwatch.punch","title":"<code>punch(latency=0)</code>","text":"<p>return elapsed time since last punch, then punch</p> <p>Parameters:</p> Name Type Description Default <code>latency</code> <p>punch <code>latency</code> seconds in the past,  unless it would be before the previous punch</p> <code>0</code> Source code in <code>src/iipyper/timing.py</code> <pre><code>def punch(self, latency=0):\n    \"\"\"return elapsed time since last punch, then punch\n\n    Args:\n        latency: punch `latency` seconds in the past, \n            unless it would be before the previous punch\n    \"\"\"\n    t = time.perf_counter_ns() - latency\n    if self.t is None:\n        dt_ns = 0\n    else:\n        t = max(self.t, t)\n        dt_ns = t - self.t\n    self.t = t\n    return dt_ns * 1e-9\n</code></pre>"},{"location":"reference/iipyper/timing/#iipyper.timing.Stopwatch.read","title":"<code>read()</code>","text":"<p>return elapsed time since last punch</p> Source code in <code>src/iipyper/timing.py</code> <pre><code>def read(self):\n    \"\"\"return elapsed time since last punch\"\"\"\n    if self.t is None:\n        return self.punch()\n    return (time.perf_counter_ns() - self.t) * 1e-9\n</code></pre>"},{"location":"reference/iipyper/timing/#iipyper.timing.Timer","title":"<code>Timer</code>","text":"<p>a threading.Timer using the global iipyper lock around the timed function. also starts automatically by default.</p> Source code in <code>src/iipyper/timing.py</code> <pre><code>class Timer:\n    \"\"\"a threading.Timer using the global iipyper lock around the timed function.\n    also starts automatically by default.\n    \"\"\"\n    def __init__(self, interval, f, lock=True, start=True, **kw):\n        self.timer = _Timer(max(0,interval), maybe_lock(f, lock), **kw)\n        if start:\n            self.start()\n    def cancel(self):\n        self.timer.cancel()\n    def start(self):\n        self.timer.start()\n</code></pre>"},{"location":"reference/iipyper/tui/","title":"Tui","text":""},{"location":"reference/iipyper/util/","title":"Util","text":""}]}