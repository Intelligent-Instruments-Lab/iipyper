{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"iipyper","text":""},{"location":"#iipyper-documentation","title":"iipyper (Documentation)","text":"<p><code>iipyper</code> is a Python package for fast creation of Open Sound Control (OSC) and MIDI-based event loops.</p> <p>It is designed for creatives who want to explore the Python ecosystem and experiment with music and, for example, machine learning.</p> <p>For examples and tutorials of how to use <code>iipyper</code>, see our examples repo (TBC).</p>"},{"location":"#install","title":"Install","text":"<p><code>iipyper</code> can be installed via PyPI:</p> <pre><code>pip install iipyper\n</code></pre>"},{"location":"#develop","title":"Develop","text":"<pre><code>git clone git@github.com:Intelligent-Instruments-Lab/iipyper.git\ncd iipyper\npoetry install iipyper\n</code></pre>"},{"location":"#contact","title":"Contact","text":"<p><code>iipyper</code> is developed by the Intelligent Instruments Lab. Get in touch to collaborate:</p> <p>\u25e6 iil.is \u25e6  Facebook \u25e6  Instagram \u25e6  X (Twitter) \u25e6  YouTube \u25e6  Discord \u25e6  GitHub \u25e6  LinkedIn \u25e6  Email \u25e6 </p>"},{"location":"#funding","title":"Funding","text":"<p>The Intelligent Instruments project (INTENT) is funded by the European Research Council (ERC) under the European Union\u2019s Horizon 2020 research and innovation programme (Grant agreement No. 101001848).</p>"},{"location":"reference/iipyper/__init__/","title":"init","text":""},{"location":"reference/iipyper/__init__/#iipyper.cleanup","title":"<code>cleanup(f=None)</code>","text":"<p>Decorate a function to be called when the iipyper app exits.</p> Source code in <code>src/iipyper/__init__.py</code> <pre><code>def cleanup(f=None):\n    \"\"\"Decorate a function to be called when the iipyper app exits.\"\"\"\n    def decorator(f):\n        _cleanup_fns.append(f)\n        return f\n\n    if f is None: # return a decorator\n        return decorator\n    else: #bare decorator case; return decorated function\n        return decorator(f)\n</code></pre>"},{"location":"reference/iipyper/__init__/#iipyper.lock","title":"<code>lock(f)</code>","text":"<p>wrap the decorated function with the global iipyper lock</p> Source code in <code>src/iipyper/__init__.py</code> <pre><code>def lock(f):\n    \"\"\"wrap the decorated function with the global iipyper lock\"\"\"\n    def decorated(*a, **kw):\n        with _lock:\n            f(*a, **kw)\n    return decorated\n</code></pre>"},{"location":"reference/iipyper/__init__/#iipyper.repeat","title":"<code>repeat(interval=None, between_calls=False, lock=True, tick=0.005)</code>","text":"<p>Decorate a function to be called repeatedly in a loop.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>float</code> <p>time in seconds to repeat at. If the decorated function returns a number,  use that as the interval until the next call</p> <code>None</code> <code>between_calls</code> <code>bool</code> <p>if True, interval is between call and next call, if False, between return and next call</p> <code>False</code> <code>lock</code> <code>bool</code> <p>if True, use the global iipyper lock to make calls thread-safe</p> <code>True</code> <code>tick</code> <code>float</code> <p>minimum interval to sleep for  (will spinlock for the remainder for more precise timing)</p> <code>0.005</code> Source code in <code>src/iipyper/__init__.py</code> <pre><code>def repeat(\n        interval:float=None, between_calls:bool=False, \n        lock:bool=True, tick:float=5e-3):\n    \"\"\"\n    Decorate a function to be called repeatedly in a loop.\n\n    Args:\n        interval: time in seconds to repeat at.\n            If the decorated function returns a number, \n            use that as the interval until the next call\n        between_calls: if True, interval is between call and next call,\n            if False, between return and next call\n        lock: if True, use the global iipyper lock to make calls thread-safe\n        tick: minimum interval to sleep for \n            (will spinlock for the remainder for more precise timing)\n    \"\"\"\n    # close the decorator over interval and lock arguments\n    def decorator(f):\n        def g():\n            # clock = Clock(tick)\n            while True:\n                t = time.perf_counter()\n                returned_interval = maybe_lock(f, lock)\n\n                if isinstance(returned_interval, Number):\n                    wait_interval = returned_interval\n                else:\n                    wait_interval = interval\n\n                # replace False or None with 0\n                wait_interval = wait_interval or 0\n\n                if between_calls:\n                    # interval is between calls to the decorated function\n                    elapsed = time.perf_counter() - t\n                    wait = wait_interval - elapsed\n                else:\n                    t = time.perf_counter()\n                    wait = wait_interval\n                # else interval is between return of one and call and next call\n                # print(f'{wait=}')\n                # tt = time.perf_counter()\n                if wait &gt; 0:\n                    sleep = wait - tick\n                    if sleep &gt; 0:\n                        time.sleep(sleep)\n                    spin_end = t + wait_interval\n                    while time.perf_counter() &lt; spin_end: pass\n                    # print(f'waited = {time.perf_counter() - tt}')\n                else:\n                    print(\n                        f'@repeat function \"{f.__name__}\" is late by {-wait}')\n\n        th = Thread(target=g, daemon=True)\n        th.start()\n        _threads.append(th)\n\n    return decorator\n</code></pre>"},{"location":"reference/iipyper/__init__/#iipyper.run","title":"<code>run(main=None)</code>","text":"<p>call this on your main function to run it as an iipyper app</p> Source code in <code>src/iipyper/__init__.py</code> <pre><code>def run(main=None):\n    \"\"\"call this on your main function to run it as an iipyper app\"\"\"\n    try:\n        if main is not None:\n            fire.Fire(main)\n\n        # non-blocking main case:\n        start_audio()\n\n        # enter a loop if there is not one in main\n        while True:\n            time.sleep(3e-2)\n\n    except KeyboardInterrupt:\n        # for th in _threads:\n            # pass\n        for a in Audio.instances:\n            a.stream.stop()\n            a.stream.close()\n        for f in _cleanup_fns:\n            f()\n        exit(0)\n</code></pre>"},{"location":"reference/iipyper/__init__/#iipyper.start_audio","title":"<code>start_audio()</code>","text":"<p>start all audio streams</p> Source code in <code>src/iipyper/__init__.py</code> <pre><code>def start_audio():\n    \"\"\"start all audio streams\"\"\"\n    for a in Audio.instances:\n        # print('????')\n        if not a.stream.active:\n            a.stream.start()\n</code></pre>"},{"location":"reference/iipyper/__init__/#iipyper.thread","title":"<code>thread(f)</code>","text":"<p>EXPERIMENTAL</p> <p>wrap a function to be called in a new thread</p> Source code in <code>src/iipyper/__init__.py</code> <pre><code>def thread(f):\n    \"\"\"\n    EXPERIMENTAL\n\n    wrap a function to be called in a new thread\n    \"\"\"\n    def g(*a, **kw):\n        th = Thread(target=f, args=a, kwargs=kw, daemon=True)\n        th.start()\n        _threads.append(th)\n    return g\n</code></pre>"},{"location":"reference/iipyper/audio/","title":"Audio","text":"Source code in <code>src/iipyper/audio.py</code> <pre><code>def audio(**kw):\n    def decorator(f):\n        def callback(indata, outdata, frames, time, status):\n            if status:\n                print(f'sounddevice error {status=}')\n            f(indata, outdata)\n        return Audio(callback=callback, **kw)\n    return decorator\n</code></pre>"},{"location":"reference/iipyper/midi/","title":"Midi","text":""},{"location":"reference/iipyper/midi/#iipyper.midi.MIDI","title":"<code>MIDI</code>","text":"<p>iipyper MIDI object. Create one of these and use it to make MIDI handlers and send MIDI:</p> <pre><code>midi = MIDI()\n\n@midi.handle\ndef my_handler(msg):\n    print(msg)\n\nmidi.note_on(channel=0, note=0, velocity=64, time=0)\n</code></pre> Source code in <code>src/iipyper/midi.py</code> <pre><code>class MIDI:\n    \"\"\"\n    iipyper MIDI object.\n    Create one of these and use it to make MIDI handlers and send MIDI:\n\n    ```python\n    midi = MIDI()\n\n    @midi.handle\n    def my_handler(msg):\n        print(msg)\n\n    midi.note_on(channel=0, note=0, velocity=64, time=0)\n    ```\n    \"\"\"\n    @classmethod\n    def print_ports(cls):\n        print('Available MIDI inputs:')\n        for s in set(mido.get_input_names()):\n            print(f'\\t{s}') \n        print('Available MIDI outputs:')\n        for s in set(mido.get_output_names()):\n            print(f'\\t{s}')\n        MIDI.ports_printed = True\n\n    ports_printed = False\n\n    def __init__(self, \n        in_ports:Optional[List[str]]=None, \n        out_ports:Optional[List[str]]=None, \n        virtual_in_ports:int=1, virtual_out_ports:int=1, \n        verbose:int=1, \n        # sleep_time:float=5e-4\n        ):\n        \"\"\"\n        Args:\n            in_ports: list of input devices to open (uses all by default)\n            out_ports: list of output devices to open (uses none by default)\n            virtual_in_ports: number of 'To iipyper X' ports to create\n            virtual_out_ports: number of 'From iipyper X' ports to create\n        \"\"\"\n        if not MIDI.ports_printed and verbose:\n            MIDI.print_ports()\n\n        self.running = False\n\n        self.verbose = int(verbose)\n        # self.sleep_time = sleep_time\n        # type -&gt; list[Optional[set[port], Optional[set[channel]], function]\n        self.handlers = []\n\n        self.handler_docs = []\n\n        if isinstance(in_ports, str):\n            in_ports = in_ports.split(',')\n        if isinstance(out_ports, str):\n            out_ports = out_ports.split(',')\n\n        # TODO: fuzzy match port names\n\n        if in_ports is None or len(in_ports)==0:\n            in_ports = set(mido.get_input_names())\n\n        self.in_ports = {}  \n        # for i in range(virtual_in_ports):\n        #     virtual_in = f'To iipyper {i+1}'\n        #     self.in_ports[virtual_in] = mido.open_input(\n        #         virtual_in, virtual=True)\n        # for port in in_ports:\n        #     try:\n        #         self.in_ports[port] = mido.open_input(\n        #             port, callback=self.get_callback(port))\n        #     except Exception:\n        #         print(f\"\"\"WARNING: MIDI input {port} not found\"\"\")\n        for port in in_ports:\n            cb = self.get_callback(port)\n            try:\n                self.in_ports[port] = mido.open_input(port, callback=cb)\n            except Exception:\n                print(f\"\"\"WARNING: failed to open MIDI input {port}\"\"\")\n        for i in range(virtual_in_ports):\n            port = f'To iipyper {i+1}'\n            cb = self.get_callback(port)\n            try:\n                self.in_ports[port] = mido.open_input(\n                    port, virtual=True, callback=cb)\n            except Exception: print(\n                f'WARNING: iipyper: failed to open virtual MIDI port {port}')\n\n        if self.verbose:\n            print(f\"\"\"opened MIDI input ports: {list(self.in_ports)}\"\"\")\n\n        ##### WIP\n        self.out_ports = {}\n        for i in range(virtual_out_ports):\n            port = f'From iipyper {i+1}'\n            try:\n                self.out_ports[port] = mido.open_output(port, virtual=True)\n            except Exception: print(\n                f'WARNING: iipyper: failed to open virtual MIDI port {port}')\n\n        if out_ports is None:\n            out_ports = []\n        # if out_ports is None or len(out_ports)==0:\n            # out_ports = set(mido.get_output_names())  \n        # self.out_ports = {}\n        for port in out_ports:\n            try:\n                self.out_ports[port] = mido.open_output(port)\n            except Exception:\n                print(f\"\"\"WARNING: MIDI output {port} not found\"\"\")\n\n        if self.verbose:\n            print(f\"\"\"opened MIDI output ports: {list(self.out_ports)}\"\"\")\n\n        self.start()\n\n    def start(self):\n        self.running = True\n\n    def handle(self, *a, **kw):\n        \"\"\"MIDI handler decorator.\n\n        Decorated function receives the following arguments:\n            `msg`: a [mido](https://mido.readthedocs.io/en/stable/messages/index.html) message\n\n        Args:\n            port: (collection of) MIDI ports to filter on\n            channel: (collection of) MIDI channels (0-index) to filter on\n            type: (collection of) MIDI event types to filter on\n            note: (collection of) MIDI note numbers to filter on\n            velocity: (collection of) MIDI velocities numbers to filter on\n            value: (collection of) MIDI values to filter on\n            control: (collection of) MIDI cc numbers to filter on\n            program: (collection of) MIDI program numbers to filter on\n        \"\"\"\n        if len(a):\n            # bare decorator\n            assert len(a)==1\n            assert len(kw)==0\n            assert hasattr(a[0], '__call__')\n            f = a[0]\n            filters = {}\n        else:\n            # with filter arguments\n            for k in kw:\n                assert k in {\n                    'channel', 'port', 'type', \n                    'note', 'velocity', 'value', \n                    'control', 'program'\n                    }, f'unknown MIDI message filter \"{k}\"'\n            filters = {k:_get_filter(v) for k,v in kw.items()}\n            f = None\n\n        def decorator(f):\n            self.handler_docs.append((kw, f.__doc__))\n\n            self.handlers.append((filters, f))\n            return f\n\n        return decorator if f is None else decorator(f)\n\n    def get_docs(self):\n        s = ''\n        for filters,doc in self.handler_docs:\n            s += str(filters)\n            if doc is not None: \n                s += doc\n            s += '\\n'\n        return s\n\n    def get_callback(self, port_name):\n        if self.verbose&gt;1: print(f'handler for MIDI port {port_name}')\n        def callback(msg):\n            if self.verbose &gt; 1:\n                print(f'filtering MIDI {msg} port={port_name}')\n            if not self.running:\n                return\n            # check each handler \n            for filters, f in self.handlers:\n                # check port\n                use_handler = (\n                    'port' not in filters \n                    or port_name in filters.pop('port'))\n                # check other filters\n                use_handler &amp;= all(\n                    filt is None \n                    or not hasattr(msg, k)\n                    or getattr(msg, k) in filt\n                    for k,filt in filters.items())\n                # call the handler if it passes the filter\n                if not use_handler:\n                    continue\n                with _lock:\n                    if self.verbose&gt;1: print(f'enter handler function {f}')\n                    try:\n                        f(msg)\n                    except Exception as e:\n                        print(f'error in MIDI handler {f}:')\n                        traceback.print_exc()\n                    if self.verbose&gt;1: print(f'exit handler function {f}')\n\n        return callback\n\n    def _send_msg(self, port, m):\n        \"\"\"send on a specific port or all output ports\"\"\"\n        ports = self.out_ports.values() if port is None else [self.out_ports[port]]\n        # print(ports)\n        for p in ports:\n            # print('iipyper send', m)\n            # iiuc mido send should already be thread safe\n            # with _lock:\n            p.send(m)\n\n    # # see https://mido.readthedocs.io/en/latest/message_types.html\n\n    def send(self, m:Union[str,mido.Message], *a, port:Optional[int]=None, **kw):\n        \"\"\"\n        send a mido message as MIDI. \n\n        These are equivalent:\n\n        ```python\n        midi.send(mido.Message('note_on', channel=0, note=0, velocity=64, time=0))\n        midi.send('note_on', channel=0, note=0, velocity=64, time=0)\n        midi.note_on(channel=0, note=0, velocity=64, time=0)\n        ```\n\n        Args:\n            m: a [mido](https://mido.readthedocs.io/en/stable/messages/index.html) message or message type\n            port: the MIDI port to send on \n                (or sends on all open ports if not specified)\n        \"\"\"\n        # print(f'SEND {time.perf_counter()}')\n        if isinstance(m, mido.Message):\n            self._send_msg(port, m)\n            if len(a)+len(kw) &gt; 0:\n                print('warning: extra arguments to MIDI send')\n        elif isinstance(m, str):\n            try:\n                self._send_msg(port, mido.Message(m, *a, **kw))\n            except Exception:\n                print('MIDI send failed: bad arguments to mido.Message')\n                raise\n        else:\n            print('MIDI send failed: first argument should be a mido.Message or str')\n\n    def __getattr__(self, name):\n        if name=='cc': name = 'control_change'\n        if name=='pc': name = 'program_change'\n        if name in (\n            'note_on', 'note_off', 'polytouch', 'control_change', \n            'program_change', 'aftertouch', 'pitchwheel', 'sysex'):\n            return lambda *a, **kw: self.send(name, *a, **kw)\n        raise AttributeError\n</code></pre>"},{"location":"reference/iipyper/midi/#iipyper.midi.MIDI.__init__","title":"<code>__init__(in_ports=None, out_ports=None, virtual_in_ports=1, virtual_out_ports=1, verbose=1)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>in_ports</code> <code>Optional[List[str]]</code> <p>list of input devices to open (uses all by default)</p> <code>None</code> <code>out_ports</code> <code>Optional[List[str]]</code> <p>list of output devices to open (uses none by default)</p> <code>None</code> <code>virtual_in_ports</code> <code>int</code> <p>number of 'To iipyper X' ports to create</p> <code>1</code> <code>virtual_out_ports</code> <code>int</code> <p>number of 'From iipyper X' ports to create</p> <code>1</code> Source code in <code>src/iipyper/midi.py</code> <pre><code>def __init__(self, \n    in_ports:Optional[List[str]]=None, \n    out_ports:Optional[List[str]]=None, \n    virtual_in_ports:int=1, virtual_out_ports:int=1, \n    verbose:int=1, \n    # sleep_time:float=5e-4\n    ):\n    \"\"\"\n    Args:\n        in_ports: list of input devices to open (uses all by default)\n        out_ports: list of output devices to open (uses none by default)\n        virtual_in_ports: number of 'To iipyper X' ports to create\n        virtual_out_ports: number of 'From iipyper X' ports to create\n    \"\"\"\n    if not MIDI.ports_printed and verbose:\n        MIDI.print_ports()\n\n    self.running = False\n\n    self.verbose = int(verbose)\n    # self.sleep_time = sleep_time\n    # type -&gt; list[Optional[set[port], Optional[set[channel]], function]\n    self.handlers = []\n\n    self.handler_docs = []\n\n    if isinstance(in_ports, str):\n        in_ports = in_ports.split(',')\n    if isinstance(out_ports, str):\n        out_ports = out_ports.split(',')\n\n    # TODO: fuzzy match port names\n\n    if in_ports is None or len(in_ports)==0:\n        in_ports = set(mido.get_input_names())\n\n    self.in_ports = {}  \n    # for i in range(virtual_in_ports):\n    #     virtual_in = f'To iipyper {i+1}'\n    #     self.in_ports[virtual_in] = mido.open_input(\n    #         virtual_in, virtual=True)\n    # for port in in_ports:\n    #     try:\n    #         self.in_ports[port] = mido.open_input(\n    #             port, callback=self.get_callback(port))\n    #     except Exception:\n    #         print(f\"\"\"WARNING: MIDI input {port} not found\"\"\")\n    for port in in_ports:\n        cb = self.get_callback(port)\n        try:\n            self.in_ports[port] = mido.open_input(port, callback=cb)\n        except Exception:\n            print(f\"\"\"WARNING: failed to open MIDI input {port}\"\"\")\n    for i in range(virtual_in_ports):\n        port = f'To iipyper {i+1}'\n        cb = self.get_callback(port)\n        try:\n            self.in_ports[port] = mido.open_input(\n                port, virtual=True, callback=cb)\n        except Exception: print(\n            f'WARNING: iipyper: failed to open virtual MIDI port {port}')\n\n    if self.verbose:\n        print(f\"\"\"opened MIDI input ports: {list(self.in_ports)}\"\"\")\n\n    ##### WIP\n    self.out_ports = {}\n    for i in range(virtual_out_ports):\n        port = f'From iipyper {i+1}'\n        try:\n            self.out_ports[port] = mido.open_output(port, virtual=True)\n        except Exception: print(\n            f'WARNING: iipyper: failed to open virtual MIDI port {port}')\n\n    if out_ports is None:\n        out_ports = []\n    # if out_ports is None or len(out_ports)==0:\n        # out_ports = set(mido.get_output_names())  \n    # self.out_ports = {}\n    for port in out_ports:\n        try:\n            self.out_ports[port] = mido.open_output(port)\n        except Exception:\n            print(f\"\"\"WARNING: MIDI output {port} not found\"\"\")\n\n    if self.verbose:\n        print(f\"\"\"opened MIDI output ports: {list(self.out_ports)}\"\"\")\n\n    self.start()\n</code></pre>"},{"location":"reference/iipyper/midi/#iipyper.midi.MIDI.handle","title":"<code>handle(*a, **kw)</code>","text":"<p>MIDI handler decorator.</p> Decorated function receives the following arguments <p><code>msg</code>: a mido message</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <p>(collection of) MIDI ports to filter on</p> required <code>channel</code> <p>(collection of) MIDI channels (0-index) to filter on</p> required <code>type</code> <p>(collection of) MIDI event types to filter on</p> required <code>note</code> <p>(collection of) MIDI note numbers to filter on</p> required <code>velocity</code> <p>(collection of) MIDI velocities numbers to filter on</p> required <code>value</code> <p>(collection of) MIDI values to filter on</p> required <code>control</code> <p>(collection of) MIDI cc numbers to filter on</p> required <code>program</code> <p>(collection of) MIDI program numbers to filter on</p> required Source code in <code>src/iipyper/midi.py</code> <pre><code>def handle(self, *a, **kw):\n    \"\"\"MIDI handler decorator.\n\n    Decorated function receives the following arguments:\n        `msg`: a [mido](https://mido.readthedocs.io/en/stable/messages/index.html) message\n\n    Args:\n        port: (collection of) MIDI ports to filter on\n        channel: (collection of) MIDI channels (0-index) to filter on\n        type: (collection of) MIDI event types to filter on\n        note: (collection of) MIDI note numbers to filter on\n        velocity: (collection of) MIDI velocities numbers to filter on\n        value: (collection of) MIDI values to filter on\n        control: (collection of) MIDI cc numbers to filter on\n        program: (collection of) MIDI program numbers to filter on\n    \"\"\"\n    if len(a):\n        # bare decorator\n        assert len(a)==1\n        assert len(kw)==0\n        assert hasattr(a[0], '__call__')\n        f = a[0]\n        filters = {}\n    else:\n        # with filter arguments\n        for k in kw:\n            assert k in {\n                'channel', 'port', 'type', \n                'note', 'velocity', 'value', \n                'control', 'program'\n                }, f'unknown MIDI message filter \"{k}\"'\n        filters = {k:_get_filter(v) for k,v in kw.items()}\n        f = None\n\n    def decorator(f):\n        self.handler_docs.append((kw, f.__doc__))\n\n        self.handlers.append((filters, f))\n        return f\n\n    return decorator if f is None else decorator(f)\n</code></pre>"},{"location":"reference/iipyper/midi/#iipyper.midi.MIDI.send","title":"<code>send(m, *a, port=None, **kw)</code>","text":"<p>send a mido message as MIDI. </p> <p>These are equivalent:</p> <pre><code>midi.send(mido.Message('note_on', channel=0, note=0, velocity=64, time=0))\nmidi.send('note_on', channel=0, note=0, velocity=64, time=0)\nmidi.note_on(channel=0, note=0, velocity=64, time=0)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>Union[str, Message]</code> <p>a mido message or message type</p> required <code>port</code> <code>Optional[int]</code> <p>the MIDI port to send on  (or sends on all open ports if not specified)</p> <code>None</code> Source code in <code>src/iipyper/midi.py</code> <pre><code>def send(self, m:Union[str,mido.Message], *a, port:Optional[int]=None, **kw):\n    \"\"\"\n    send a mido message as MIDI. \n\n    These are equivalent:\n\n    ```python\n    midi.send(mido.Message('note_on', channel=0, note=0, velocity=64, time=0))\n    midi.send('note_on', channel=0, note=0, velocity=64, time=0)\n    midi.note_on(channel=0, note=0, velocity=64, time=0)\n    ```\n\n    Args:\n        m: a [mido](https://mido.readthedocs.io/en/stable/messages/index.html) message or message type\n        port: the MIDI port to send on \n            (or sends on all open ports if not specified)\n    \"\"\"\n    # print(f'SEND {time.perf_counter()}')\n    if isinstance(m, mido.Message):\n        self._send_msg(port, m)\n        if len(a)+len(kw) &gt; 0:\n            print('warning: extra arguments to MIDI send')\n    elif isinstance(m, str):\n        try:\n            self._send_msg(port, mido.Message(m, *a, **kw))\n        except Exception:\n            print('MIDI send failed: bad arguments to mido.Message')\n            raise\n    else:\n        print('MIDI send failed: first argument should be a mido.Message or str')\n</code></pre>"},{"location":"reference/iipyper/osc/","title":"Osc","text":""},{"location":"reference/iipyper/osc/#iipyper.osc.OSC","title":"<code>OSC</code>","text":"<p>iipyper OSC object. Create one of these and use it to make OSC handlers and send OSC:</p> <pre><code># make an OSC object receiving on port 9999\nosc = OSC(port=9999)\n\n# receive OSC messages at '/my_route'\n@osc.handle\ndef my_route(route, *osc_items):\n    print(route, osc_items)\n\n# with wildcard route and replies:\n@osc.handle('/my_wildcard_route/*')\ndef _(route, *osc_items):\n    print(route, osc_items)\n    # return value sends a reply\n    return '/echo' + route, *osc_items\n\n# create an OSC client and send it a message\nosc.create_client('my_client', host='127.0.0.1', port=8888)\nosc.send('/my/osc/route', 0, 1.0, 'abc', client='my_client')\n</code></pre> Source code in <code>src/iipyper/osc.py</code> <pre><code>class OSC():\n    \"\"\"\n    iipyper OSC object.\n    Create one of these and use it to make OSC handlers and send OSC:\n\n    ```python\n    # make an OSC object receiving on port 9999\n    osc = OSC(port=9999)\n\n    # receive OSC messages at '/my_route'\n    @osc.handle\n    def my_route(route, *osc_items):\n        print(route, osc_items)\n\n    # with wildcard route and replies:\n    @osc.handle('/my_wildcard_route/*')\n    def _(route, *osc_items):\n        print(route, osc_items)\n        # return value sends a reply\n        return '/echo' + route, *osc_items\n\n    # create an OSC client and send it a message\n    osc.create_client('my_client', host='127.0.0.1', port=8888)\n    osc.send('/my/osc/route', 0, 1.0, 'abc', client='my_client')\n    ```\n    \"\"\"\n    def __init__(self, \n        host:str=\"127.0.0.1\", port:int=9999, \n        verbose:int=1, concurrent:bool=False):\n        \"\"\"\n        TODO: Expand to support multiple IPs + ports\n\n        Args:\n            host (str): IP address\n            port (int): port to receive on\n            verbose (bool): whether to print activity\n            concurrent (bool): if True, handle each incoming OSC message on \n                its own thread. otherwise, incoming OSC is handled serially on \n                one thread for the whole OSC object.\n        \"\"\"\n        self.verbose = verbose\n        self.concurrent = concurrent\n        self.host = host\n        self.port = port\n        self.dispatcher = Dispatcher()\n        self.server = None\n        self.clients = {} # (host,port) -&gt; client\n        self.client_names = {} # (name) -&gt; (host,port)\n\n        self.handler_docs = []\n\n        self.create_server()\n\n    def create_server(self):#, host=None, port=None):\n        \"\"\"\n        Create the server\n        \"\"\"\n        # if (host is None):\n        #     host = self.host\n        # if (port is None):\n        #     port = self.port\n        cls = ThreadingOSCUDPServer if self.concurrent else BlockingOSCUDPServer\n\n        if (self.server is None):\n            self.server = cls((self.host, self.port), self.dispatcher)\n            if self.verbose &gt; 0:\n                print(f\"OSC server created {self.host}:{self.port}\")\n\n            # start the OSC server on its own thread\n            Thread(target=self.server.serve_forever, daemon=True).start()\n            # self.server.serve_forever()\n        else:\n            print(\"OSC server already exists\")\n\n    # def close_server(self):\n    #     \"\"\"\n    #     Close the server\n    #     \"\"\"\n    #     if (self.server is not None):\n    #         self.transport.close()\n    #     else:\n    #         print(\"OSC server does not exist\")\n\n    def add_handler(self, address, handler):\n        \"\"\"\n        Map the custom message handler to the OSC dispatcher\n        \"\"\"\n        # if (self.server is not None):\n        self.dispatcher.map(address, handler, needs_reply_address=True)\n\n    def create_client(self, name:str, host:Optional[str]=None, port:Optional[int]=None):\n        \"\"\"\n        Add an OSC client.\n        Args:\n            name: name this client\n            host (str): IP to send to, defaults to same as server\n            port (int): port to send to, defaults to 57120 (supercollider)\n        \"\"\"\n        if (host == None):\n            host = self.host\n        if (port == None):\n            port = 57120\n        if ((host, port) not in self.clients):\n            self.clients[host, port] = SimpleUDPClient(host, port)\n            if self.verbose &gt; 0:\n                print(f\"OSC client created {host}:{port}\")\n        else:\n            print(\"OSC client already exists\")\n        self.client_names[name] = (host, port)\n\n    def get_client_by_name(self, name):\n        try:\n            return self.clients[self.client_names[name]]\n        except Exception:\n            print(f'no client with name \"{name}\"')\n            return None\n\n    def get_client_by_sender(self, address):\n        if address not in self.clients:\n            host, port = address\n            self.create_client(f'{host}:{port}', host, port)\n        return self.clients[address]\n\n    def send(self, route:str, *msg, client:Optional[str]=None):\n        \"\"\"\n        Send message to default client, or with client in address\n\n        Args:\n            route: e.g. '/my/osc/route' or 'host:port/my/osc/route'\n            *msg: contents of OSC message\n            client: name of OSC client or None to use default client\n        \"\"\"\n        if len(self.clients)==0:\n            print('ERROR: iipyper: send: no OSC clients. use `create_client` to make one.')\n            return\n\n        if client is not None:\n            client = self.get_client_by_name(client)\n        elif ':' in route:\n            try:\n                client_str, route = route.split('/', 1)\n                assert ':' in client_str\n                host, port = client_str.split(':')\n                assert '/' not in host\n                port = int(port)\n                client = self.get_client_by_sender((host, port))\n            except Exception:\n                print(f'failed to get client address from OSC route \"{route}\"')\n        else:\n            client = next(iter(self.clients.values()))\n\n        if client is None:\n            print(f'OSC message failed to send, could not determine client')\n            return\n\n        if not route.startswith('/'):\n            route = '/'+route\n        client.send_message(route, msg)\n        if self.verbose &gt; 0:\n            print(f\"OSC message sent {route}:{msg}\")\n\n    def handle(self, \n            route:str=None, return_host:str=None, return_port:int=None,\n            allow_pos=None, allow_kw=True, lock=True, doc:str=None):\n        \"\"\"\n        OSC handler decorator supporting mixed args and kwargs, typing.\n\n        The decorated function will receive the OSC route as its first argument.\n        Further arguments will be the elements of the OSC message, which can be\n        converted in various ways by supplying type annotations (see below).\n\n        If the decorated function returns a value, it should be a tuple beginning\n        with the OSC route to reply to, followed by the message contents.\n\n        Args:\n            route: OSC path for this handler. If not given,\n                use the name of the decorated function.\n                If this is a callable, assume the decorator is being used 'bare'\n                with all arguments set to default values, i.e. `osc.handle(f)`\n                is equivalent to `osc.handle()(f)`.\n            return_host: hostname of reply address for return value.\n                if not given, reply to sender.\n            return_port: port of reply address for return value.\n                if not given, reply to sender port.\n                NOTE: replying on the same port seems to work with SuperCollider,\n                but not with Max.\n            kwargs: if True (default), parse OSC message for key-value pairs\n                corresponding to named arguments of the decorated function.\n            lock: if True (default), use the global iipyper lock around the\n                decorated function\n            doc: replace the docstring of the decorated function\n\n        keyword arguments of the decorated function:\n            if a string with the same name as a parameter is found, \n            the following item in the OSC message will be used as the value.\n            positional arguments can still be used before any keyword pairs,\n            like in Python.\n\n            Example:\n            ```\n            @osc.handle\n            def my_func(route, a, b, c=2, d=3):\n                print(f'{a=}, {b=}, {c=}, {d=}')\n            ```\n            OSC message: /my_func/ 0 1 2 'd' 3\n            prints: \"a=0, b=1, c=2, d=3\"\n\n            This is idiomatic in SuperCollider, where flat key, value pairs are\n            seen, e.g. `~synth.set('freq', 440, 'amp', 0.2)`\n            It's also often easier than managing nested data structures in Max/Pd.\n\n            However, there can be ambiguity when strings are positional arguments.\n            It's recommended to avoid using strings as positional arguments, \n            or else to ensure that there will be no collision with the names\n            of arguments to the decorated function, \n            for example by adding _ to your argument names.\n            you can also disable the keyword argument parsing with `kwargs=False`.\n\n        type annotations:\n            object:\n                If the argument is a string, decode as JSON.\n                If the argument is a bytes, decode through pickle.\n\n            Splat[N]: \n                consume N consecutive items from the OSC message items into a \n                tuple, which forms one argument to the decorated function.\n\n                @osc.handle\n                f(a:Splat[2], b:Splat[3]) \n                OSC Message: /f 0 banana 2 3 4.5\n                a = (0, banana)\n                b = (2, 3, 4.5) \n\n            Splat[None]: \n                consume items up to the next keyword item into a list\n                NOTE: generally should not be used when there are strings \n                in the OSC message, and must be used as a keyword argument, \n                since a str matching an argument name delimits the end of the\n                Splat (unless the Splat is the final argument).\n\n                f(a:Splat[None]) -- fine, collects all arguments into a list\n                f(a:Splat[None], b:Splat[None]=None) -- breaks if `a` should \n                contain a string `'b'`.\n                    OSC message: /f a 0 1 2 b 3 4\n                    would call `f('/f', [0,1,2], [3,4])`.\n\n            NDArray: \n                decode a string (either JSON or repr format) to a numpy array\n                    JSON format: see `iipyper.ndarray_to_json`\n                        (no support for complex dtypes)\n                    repr format: see `numpy.array_repr`\n                decode bytes to a 1-dimensional float32 array\n                    TODO: support annotating dtype via pydantic_numpy types\n\n            other types:\n                will be decoded by python-osc and validated by pydantic\n\n        \"\"\"\n        if hasattr(route, '__call__'):\n            # bare decorator\n            f = route\n            route = None\n        else:\n            f = None\n\n        def decorator(f, route=route, \n                return_host=return_host, return_port=return_port,\n                allow_pos=allow_pos, allow_kw=allow_kw, doc=doc):\n            # default_route = f'/{f.__name__}/*'\n            if route is None:\n                route = f'/{f.__name__}'\n            # print(route)\n            assert isinstance(route, str) and route.startswith('/')\n\n            # get info out of function signature\n            sig = inspect.signature(f)\n\n            positional_params = []\n            named_params = {}\n            has_varp = False\n            has_varkw = False\n            all_default = True\n            pos = True\n            for i,(name,p) in enumerate(sig.parameters.items()):\n                if i==0:\n                    # skip first argument (the OSC route)\n                    continue\n                # print(p, p.kind)\n\n                if p.kind == p.VAR_POSITIONAL:\n                    pos = False # no more positional args after variadic\n                    all_default = False\n                elif p.kind == p.VAR_KEYWORD:\n                    pos = False # no more positional args after variadic\n                else:\n                    if p.default == p.empty:\n                        all_default = False\n                    named_params[name] = p\n                    if pos:\n                        positional_params.append(p)\n                has_varp |= p.kind==p.VAR_POSITIONAL\n                has_varkw |= p.kind==p.VAR_KEYWORD\n\n            # set allow_pos to False if it hasn't been explicitly set to True,\n            # and all parameters have defaults or are VAR_KEYWORD\n            if allow_pos is None:\n                allow_pos = not all_default\n\n            if has_varkw and not allow_kw:\n                raise ValueError(f\"\"\"\n                ERROR: iipyper: OSC handler {f} was created with kwargs=False,\n                but the decorated function has a ** argument\n                \"\"\")\n            if has_varp and not allow_pos:\n                raise ValueError(f\"\"\"\n                ERROR: iipyper: OSC handler {f} was created with args=False,\n                but the decorated function has a * argument\n                \"\"\")\n\n            doc = doc or f.__doc__\n            self.handler_docs.append((route, doc))\n\n            # wrap with pydantic validation decorator\n            f = pydantic.validate_call(f)\n\n            def handler(client, address, *osc_items):\n                \"\"\"\n                Args:\n                    client: (host,port) of sender\n                    address: full OSC address\n                    *args: content of OSC message\n                \"\"\"\n                try:\n                    args, kw = _parse_osc_items(\n                        osc_items, \n                        (positional_params, named_params, has_varp, has_varkw), \n                        allow_pos, allow_kw,\n                        self.verbose\n                    )\n                except Exception:\n                    raise ValueError(f\"\"\"\n                    {address} {osc_items}\n                    failed to parse OSC for function with signature: {sig}\n                    \"\"\")\n                # print(f'{args=}, {kw=}')\n\n                try:\n                    r = maybe_lock(f, lock, address, *args, **kw)\n                    # if there was a return value,\n                    # send it as a message back to the sender\n                    if r is not None:\n                        if not hasattr(r, '__len__'):\n                            print(\"\"\"\n                            value returned from OSC handler should start with route\n                            \"\"\")\n                        else:\n                            client = (\n                                client[0] if return_host is None else return_host,\n                                client[1] if return_port is None else return_port\n                            )\n                            if self.verbose &gt; 0:\n                                print('iipyper OSC return', client, r)\n                            try:\n                                self.get_client_by_sender(client).send_message(\n                                    r[0], r[1:])\n                            except ValueError:\n                                rt = [type(item) for item in r]\n                                print(\n                                    f'iipyper OSC return to {r[0]} failed,' \n                                    f'possibly an unsupported type in {rt}')\n\n                except pydantic.ValidationError as e:\n                    print(f'ERROR: iipyper OSC handler:')\n                    for info in e.errors(include_url=False):\n                        msg = info['msg']\n                        loc = info['loc']\n                        inp = info['input']\n                        print(f'\\t{inp.args} {inp.kwargs}')\n                        print(f'\\t{msg} {loc}')\n\n            self.add_handler(route, handler)\n            return f\n\n        return decorator if f is None else decorator(f)\n\n    def args(self, route=None, return_host=None, return_port=None):\n        \"\"\"like `handle`, but only positional arguments are allowed.\n\n        able to parse some edge cases which `handle` cannot.\n        \"\"\"\n        return self.handle(\n            route, return_host, return_port, \n            allow_pos=True, allow_kw=False)\n\n    def kwargs(self, route=None, return_host=None, return_port=None, \n               json_keys=None):\n        \"\"\"like `handle`, but only keyword arguments are allowed.\n\n        able to parse some edge cases which `handle` cannot.\n        \"\"\"\n        if json_keys is not None:\n            raise ValueError(f\"\"\"\n            OSC.kwargs {route}: `json_keys` has been removed.\n            replace `json_keys` with type annotation of arguments as `object`.\n            consider using `OSC.handle` instead of `OSC.kwargs`.\n            \"\"\")\n        return self.handle(\n            route, return_host, return_port,\n            allow_pos=False, allow_kw=True)\n\n    def get_docs(self):\n        \"\"\"return a string built from routes and docstrings of osc handlers\"\"\"\n        s = ''\n        for route,doc in self.handler_docs:\n            s += route\n            if doc is not None: \n                s += doc\n            s += '\\n'\n        return s\n\n    def __call__(self, client:str, *a, **kw):\n        \"\"\"\n        alternate syntax for `send` with client name first\n\n        `osc('my_client_name', 0, 1, 'message contents', None)`\n\n        Args:\n            client: name of OSC client created with `create_client`.\n        \"\"\"\n        self.send(*a, client=client, **kw)\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.__call__","title":"<code>__call__(client, *a, **kw)</code>","text":"<p>alternate syntax for <code>send</code> with client name first</p> <p><code>osc('my_client_name', 0, 1, 'message contents', None)</code></p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>str</code> <p>name of OSC client created with <code>create_client</code>.</p> required Source code in <code>src/iipyper/osc.py</code> <pre><code>def __call__(self, client:str, *a, **kw):\n    \"\"\"\n    alternate syntax for `send` with client name first\n\n    `osc('my_client_name', 0, 1, 'message contents', None)`\n\n    Args:\n        client: name of OSC client created with `create_client`.\n    \"\"\"\n    self.send(*a, client=client, **kw)\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.__init__","title":"<code>__init__(host='127.0.0.1', port=9999, verbose=1, concurrent=False)</code>","text":"<p>TODO: Expand to support multiple IPs + ports</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>IP address</p> <code>'127.0.0.1'</code> <code>port</code> <code>int</code> <p>port to receive on</p> <code>9999</code> <code>verbose</code> <code>bool</code> <p>whether to print activity</p> <code>1</code> <code>concurrent</code> <code>bool</code> <p>if True, handle each incoming OSC message on  its own thread. otherwise, incoming OSC is handled serially on  one thread for the whole OSC object.</p> <code>False</code> Source code in <code>src/iipyper/osc.py</code> <pre><code>def __init__(self, \n    host:str=\"127.0.0.1\", port:int=9999, \n    verbose:int=1, concurrent:bool=False):\n    \"\"\"\n    TODO: Expand to support multiple IPs + ports\n\n    Args:\n        host (str): IP address\n        port (int): port to receive on\n        verbose (bool): whether to print activity\n        concurrent (bool): if True, handle each incoming OSC message on \n            its own thread. otherwise, incoming OSC is handled serially on \n            one thread for the whole OSC object.\n    \"\"\"\n    self.verbose = verbose\n    self.concurrent = concurrent\n    self.host = host\n    self.port = port\n    self.dispatcher = Dispatcher()\n    self.server = None\n    self.clients = {} # (host,port) -&gt; client\n    self.client_names = {} # (name) -&gt; (host,port)\n\n    self.handler_docs = []\n\n    self.create_server()\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.add_handler","title":"<code>add_handler(address, handler)</code>","text":"<p>Map the custom message handler to the OSC dispatcher</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def add_handler(self, address, handler):\n    \"\"\"\n    Map the custom message handler to the OSC dispatcher\n    \"\"\"\n    # if (self.server is not None):\n    self.dispatcher.map(address, handler, needs_reply_address=True)\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.args","title":"<code>args(route=None, return_host=None, return_port=None)</code>","text":"<p>like <code>handle</code>, but only positional arguments are allowed.</p> <p>able to parse some edge cases which <code>handle</code> cannot.</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def args(self, route=None, return_host=None, return_port=None):\n    \"\"\"like `handle`, but only positional arguments are allowed.\n\n    able to parse some edge cases which `handle` cannot.\n    \"\"\"\n    return self.handle(\n        route, return_host, return_port, \n        allow_pos=True, allow_kw=False)\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.create_client","title":"<code>create_client(name, host=None, port=None)</code>","text":"<p>Add an OSC client. Args:     name: name this client     host (str): IP to send to, defaults to same as server     port (int): port to send to, defaults to 57120 (supercollider)</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def create_client(self, name:str, host:Optional[str]=None, port:Optional[int]=None):\n    \"\"\"\n    Add an OSC client.\n    Args:\n        name: name this client\n        host (str): IP to send to, defaults to same as server\n        port (int): port to send to, defaults to 57120 (supercollider)\n    \"\"\"\n    if (host == None):\n        host = self.host\n    if (port == None):\n        port = 57120\n    if ((host, port) not in self.clients):\n        self.clients[host, port] = SimpleUDPClient(host, port)\n        if self.verbose &gt; 0:\n            print(f\"OSC client created {host}:{port}\")\n    else:\n        print(\"OSC client already exists\")\n    self.client_names[name] = (host, port)\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.create_server","title":"<code>create_server()</code>","text":"<p>Create the server</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def create_server(self):#, host=None, port=None):\n    \"\"\"\n    Create the server\n    \"\"\"\n    # if (host is None):\n    #     host = self.host\n    # if (port is None):\n    #     port = self.port\n    cls = ThreadingOSCUDPServer if self.concurrent else BlockingOSCUDPServer\n\n    if (self.server is None):\n        self.server = cls((self.host, self.port), self.dispatcher)\n        if self.verbose &gt; 0:\n            print(f\"OSC server created {self.host}:{self.port}\")\n\n        # start the OSC server on its own thread\n        Thread(target=self.server.serve_forever, daemon=True).start()\n        # self.server.serve_forever()\n    else:\n        print(\"OSC server already exists\")\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.get_docs","title":"<code>get_docs()</code>","text":"<p>return a string built from routes and docstrings of osc handlers</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def get_docs(self):\n    \"\"\"return a string built from routes and docstrings of osc handlers\"\"\"\n    s = ''\n    for route,doc in self.handler_docs:\n        s += route\n        if doc is not None: \n            s += doc\n        s += '\\n'\n    return s\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.handle","title":"<code>handle(route=None, return_host=None, return_port=None, allow_pos=None, allow_kw=True, lock=True, doc=None)</code>","text":"<p>OSC handler decorator supporting mixed args and kwargs, typing.</p> <p>The decorated function will receive the OSC route as its first argument. Further arguments will be the elements of the OSC message, which can be converted in various ways by supplying type annotations (see below).</p> <p>If the decorated function returns a value, it should be a tuple beginning with the OSC route to reply to, followed by the message contents.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>OSC path for this handler. If not given, use the name of the decorated function. If this is a callable, assume the decorator is being used 'bare' with all arguments set to default values, i.e. <code>osc.handle(f)</code> is equivalent to <code>osc.handle()(f)</code>.</p> <code>None</code> <code>return_host</code> <code>str</code> <p>hostname of reply address for return value. if not given, reply to sender.</p> <code>None</code> <code>return_port</code> <code>int</code> <p>port of reply address for return value. if not given, reply to sender port. NOTE: replying on the same port seems to work with SuperCollider, but not with Max.</p> <code>None</code> <code>kwargs</code> <p>if True (default), parse OSC message for key-value pairs corresponding to named arguments of the decorated function.</p> required <code>lock</code> <p>if True (default), use the global iipyper lock around the decorated function</p> <code>True</code> <code>doc</code> <code>str</code> <p>replace the docstring of the decorated function</p> <code>None</code> keyword arguments of the decorated function <p>if a string with the same name as a parameter is found,  the following item in the OSC message will be used as the value. positional arguments can still be used before any keyword pairs, like in Python.</p> <p>Example: <pre><code>@osc.handle\ndef my_func(route, a, b, c=2, d=3):\n    print(f'{a=}, {b=}, {c=}, {d=}')\n</code></pre> OSC message: /my_func/ 0 1 2 'd' 3 prints: \"a=0, b=1, c=2, d=3\"</p> <p>This is idiomatic in SuperCollider, where flat key, value pairs are seen, e.g. <code>~synth.set('freq', 440, 'amp', 0.2)</code> It's also often easier than managing nested data structures in Max/Pd.</p> <p>However, there can be ambiguity when strings are positional arguments. It's recommended to avoid using strings as positional arguments,  or else to ensure that there will be no collision with the names of arguments to the decorated function,  for example by adding _ to your argument names. you can also disable the keyword argument parsing with <code>kwargs=False</code>.</p> type annotations <p>object:     If the argument is a string, decode as JSON.     If the argument is a bytes, decode through pickle.</p> <p>Splat[N]:      consume N consecutive items from the OSC message items into a      tuple, which forms one argument to the decorated function.</p> <pre><code>@osc.handle\nf(a:Splat[2], b:Splat[3]) \nOSC Message: /f 0 banana 2 3 4.5\na = (0, banana)\nb = (2, 3, 4.5)\n</code></pre> <p>Splat[None]:      consume items up to the next keyword item into a list     NOTE: generally should not be used when there are strings      in the OSC message, and must be used as a keyword argument,      since a str matching an argument name delimits the end of the     Splat (unless the Splat is the final argument).</p> <pre><code>f(a:Splat[None]) -- fine, collects all arguments into a list\nf(a:Splat[None], b:Splat[None]=None) -- breaks if `a` should \ncontain a string `'b'`.\n    OSC message: /f a 0 1 2 b 3 4\n    would call `f('/f', [0,1,2], [3,4])`.\n</code></pre> <p>NDArray:      decode a string (either JSON or repr format) to a numpy array         JSON format: see <code>iipyper.ndarray_to_json</code>             (no support for complex dtypes)         repr format: see <code>numpy.array_repr</code>     decode bytes to a 1-dimensional float32 array         TODO: support annotating dtype via pydantic_numpy types</p> <p>other types:     will be decoded by python-osc and validated by pydantic</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def handle(self, \n        route:str=None, return_host:str=None, return_port:int=None,\n        allow_pos=None, allow_kw=True, lock=True, doc:str=None):\n    \"\"\"\n    OSC handler decorator supporting mixed args and kwargs, typing.\n\n    The decorated function will receive the OSC route as its first argument.\n    Further arguments will be the elements of the OSC message, which can be\n    converted in various ways by supplying type annotations (see below).\n\n    If the decorated function returns a value, it should be a tuple beginning\n    with the OSC route to reply to, followed by the message contents.\n\n    Args:\n        route: OSC path for this handler. If not given,\n            use the name of the decorated function.\n            If this is a callable, assume the decorator is being used 'bare'\n            with all arguments set to default values, i.e. `osc.handle(f)`\n            is equivalent to `osc.handle()(f)`.\n        return_host: hostname of reply address for return value.\n            if not given, reply to sender.\n        return_port: port of reply address for return value.\n            if not given, reply to sender port.\n            NOTE: replying on the same port seems to work with SuperCollider,\n            but not with Max.\n        kwargs: if True (default), parse OSC message for key-value pairs\n            corresponding to named arguments of the decorated function.\n        lock: if True (default), use the global iipyper lock around the\n            decorated function\n        doc: replace the docstring of the decorated function\n\n    keyword arguments of the decorated function:\n        if a string with the same name as a parameter is found, \n        the following item in the OSC message will be used as the value.\n        positional arguments can still be used before any keyword pairs,\n        like in Python.\n\n        Example:\n        ```\n        @osc.handle\n        def my_func(route, a, b, c=2, d=3):\n            print(f'{a=}, {b=}, {c=}, {d=}')\n        ```\n        OSC message: /my_func/ 0 1 2 'd' 3\n        prints: \"a=0, b=1, c=2, d=3\"\n\n        This is idiomatic in SuperCollider, where flat key, value pairs are\n        seen, e.g. `~synth.set('freq', 440, 'amp', 0.2)`\n        It's also often easier than managing nested data structures in Max/Pd.\n\n        However, there can be ambiguity when strings are positional arguments.\n        It's recommended to avoid using strings as positional arguments, \n        or else to ensure that there will be no collision with the names\n        of arguments to the decorated function, \n        for example by adding _ to your argument names.\n        you can also disable the keyword argument parsing with `kwargs=False`.\n\n    type annotations:\n        object:\n            If the argument is a string, decode as JSON.\n            If the argument is a bytes, decode through pickle.\n\n        Splat[N]: \n            consume N consecutive items from the OSC message items into a \n            tuple, which forms one argument to the decorated function.\n\n            @osc.handle\n            f(a:Splat[2], b:Splat[3]) \n            OSC Message: /f 0 banana 2 3 4.5\n            a = (0, banana)\n            b = (2, 3, 4.5) \n\n        Splat[None]: \n            consume items up to the next keyword item into a list\n            NOTE: generally should not be used when there are strings \n            in the OSC message, and must be used as a keyword argument, \n            since a str matching an argument name delimits the end of the\n            Splat (unless the Splat is the final argument).\n\n            f(a:Splat[None]) -- fine, collects all arguments into a list\n            f(a:Splat[None], b:Splat[None]=None) -- breaks if `a` should \n            contain a string `'b'`.\n                OSC message: /f a 0 1 2 b 3 4\n                would call `f('/f', [0,1,2], [3,4])`.\n\n        NDArray: \n            decode a string (either JSON or repr format) to a numpy array\n                JSON format: see `iipyper.ndarray_to_json`\n                    (no support for complex dtypes)\n                repr format: see `numpy.array_repr`\n            decode bytes to a 1-dimensional float32 array\n                TODO: support annotating dtype via pydantic_numpy types\n\n        other types:\n            will be decoded by python-osc and validated by pydantic\n\n    \"\"\"\n    if hasattr(route, '__call__'):\n        # bare decorator\n        f = route\n        route = None\n    else:\n        f = None\n\n    def decorator(f, route=route, \n            return_host=return_host, return_port=return_port,\n            allow_pos=allow_pos, allow_kw=allow_kw, doc=doc):\n        # default_route = f'/{f.__name__}/*'\n        if route is None:\n            route = f'/{f.__name__}'\n        # print(route)\n        assert isinstance(route, str) and route.startswith('/')\n\n        # get info out of function signature\n        sig = inspect.signature(f)\n\n        positional_params = []\n        named_params = {}\n        has_varp = False\n        has_varkw = False\n        all_default = True\n        pos = True\n        for i,(name,p) in enumerate(sig.parameters.items()):\n            if i==0:\n                # skip first argument (the OSC route)\n                continue\n            # print(p, p.kind)\n\n            if p.kind == p.VAR_POSITIONAL:\n                pos = False # no more positional args after variadic\n                all_default = False\n            elif p.kind == p.VAR_KEYWORD:\n                pos = False # no more positional args after variadic\n            else:\n                if p.default == p.empty:\n                    all_default = False\n                named_params[name] = p\n                if pos:\n                    positional_params.append(p)\n            has_varp |= p.kind==p.VAR_POSITIONAL\n            has_varkw |= p.kind==p.VAR_KEYWORD\n\n        # set allow_pos to False if it hasn't been explicitly set to True,\n        # and all parameters have defaults or are VAR_KEYWORD\n        if allow_pos is None:\n            allow_pos = not all_default\n\n        if has_varkw and not allow_kw:\n            raise ValueError(f\"\"\"\n            ERROR: iipyper: OSC handler {f} was created with kwargs=False,\n            but the decorated function has a ** argument\n            \"\"\")\n        if has_varp and not allow_pos:\n            raise ValueError(f\"\"\"\n            ERROR: iipyper: OSC handler {f} was created with args=False,\n            but the decorated function has a * argument\n            \"\"\")\n\n        doc = doc or f.__doc__\n        self.handler_docs.append((route, doc))\n\n        # wrap with pydantic validation decorator\n        f = pydantic.validate_call(f)\n\n        def handler(client, address, *osc_items):\n            \"\"\"\n            Args:\n                client: (host,port) of sender\n                address: full OSC address\n                *args: content of OSC message\n            \"\"\"\n            try:\n                args, kw = _parse_osc_items(\n                    osc_items, \n                    (positional_params, named_params, has_varp, has_varkw), \n                    allow_pos, allow_kw,\n                    self.verbose\n                )\n            except Exception:\n                raise ValueError(f\"\"\"\n                {address} {osc_items}\n                failed to parse OSC for function with signature: {sig}\n                \"\"\")\n            # print(f'{args=}, {kw=}')\n\n            try:\n                r = maybe_lock(f, lock, address, *args, **kw)\n                # if there was a return value,\n                # send it as a message back to the sender\n                if r is not None:\n                    if not hasattr(r, '__len__'):\n                        print(\"\"\"\n                        value returned from OSC handler should start with route\n                        \"\"\")\n                    else:\n                        client = (\n                            client[0] if return_host is None else return_host,\n                            client[1] if return_port is None else return_port\n                        )\n                        if self.verbose &gt; 0:\n                            print('iipyper OSC return', client, r)\n                        try:\n                            self.get_client_by_sender(client).send_message(\n                                r[0], r[1:])\n                        except ValueError:\n                            rt = [type(item) for item in r]\n                            print(\n                                f'iipyper OSC return to {r[0]} failed,' \n                                f'possibly an unsupported type in {rt}')\n\n            except pydantic.ValidationError as e:\n                print(f'ERROR: iipyper OSC handler:')\n                for info in e.errors(include_url=False):\n                    msg = info['msg']\n                    loc = info['loc']\n                    inp = info['input']\n                    print(f'\\t{inp.args} {inp.kwargs}')\n                    print(f'\\t{msg} {loc}')\n\n        self.add_handler(route, handler)\n        return f\n\n    return decorator if f is None else decorator(f)\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.kwargs","title":"<code>kwargs(route=None, return_host=None, return_port=None, json_keys=None)</code>","text":"<p>like <code>handle</code>, but only keyword arguments are allowed.</p> <p>able to parse some edge cases which <code>handle</code> cannot.</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def kwargs(self, route=None, return_host=None, return_port=None, \n           json_keys=None):\n    \"\"\"like `handle`, but only keyword arguments are allowed.\n\n    able to parse some edge cases which `handle` cannot.\n    \"\"\"\n    if json_keys is not None:\n        raise ValueError(f\"\"\"\n        OSC.kwargs {route}: `json_keys` has been removed.\n        replace `json_keys` with type annotation of arguments as `object`.\n        consider using `OSC.handle` instead of `OSC.kwargs`.\n        \"\"\")\n    return self.handle(\n        route, return_host, return_port,\n        allow_pos=False, allow_kw=True)\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSC.send","title":"<code>send(route, *msg, client=None)</code>","text":"<p>Send message to default client, or with client in address</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>str</code> <p>e.g. '/my/osc/route' or 'host:port/my/osc/route'</p> required <code>*msg</code> <p>contents of OSC message</p> <code>()</code> <code>client</code> <code>Optional[str]</code> <p>name of OSC client or None to use default client</p> <code>None</code> Source code in <code>src/iipyper/osc.py</code> <pre><code>def send(self, route:str, *msg, client:Optional[str]=None):\n    \"\"\"\n    Send message to default client, or with client in address\n\n    Args:\n        route: e.g. '/my/osc/route' or 'host:port/my/osc/route'\n        *msg: contents of OSC message\n        client: name of OSC client or None to use default client\n    \"\"\"\n    if len(self.clients)==0:\n        print('ERROR: iipyper: send: no OSC clients. use `create_client` to make one.')\n        return\n\n    if client is not None:\n        client = self.get_client_by_name(client)\n    elif ':' in route:\n        try:\n            client_str, route = route.split('/', 1)\n            assert ':' in client_str\n            host, port = client_str.split(':')\n            assert '/' not in host\n            port = int(port)\n            client = self.get_client_by_sender((host, port))\n        except Exception:\n            print(f'failed to get client address from OSC route \"{route}\"')\n    else:\n        client = next(iter(self.clients.values()))\n\n    if client is None:\n        print(f'OSC message failed to send, could not determine client')\n        return\n\n    if not route.startswith('/'):\n        route = '/'+route\n    client.send_message(route, msg)\n    if self.verbose &gt; 0:\n        print(f\"OSC message sent {route}:{msg}\")\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCReceiveListUpdater","title":"<code>OSCReceiveListUpdater</code>","text":"<p>             Bases: <code>ReceiveListUpdater</code></p> <p>ReceiveListUpdater with an OSC handler</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>class OSCReceiveListUpdater(ReceiveListUpdater):\n    '''\n    ReceiveListUpdater with an OSC handler\n    '''\n\n    def __init__(self, osc, address: str, f, state=None, count=10, update=False):\n        super().__init__(f, state, count, update)\n        self.osc = osc\n        self.address = address\n        osc.add_handler(self.address, self.receive)\n\n    def receive(self, address, *args):\n        self.set(list(args[1:]))\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCReceiveUpdater","title":"<code>OSCReceiveUpdater</code>","text":"<p>             Bases: <code>ReceiveUpdater</code></p> <p>ReceiveUpdater with an OSC handler</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>class OSCReceiveUpdater(ReceiveUpdater):\n    '''\n    ReceiveUpdater with an OSC handler\n    '''\n\n    def __init__(self, osc, address: str, f, state=None, count=10, update=False):\n        super().__init__(f, state, count, update)\n        self.osc = osc\n        self.address = address\n        osc.add_handler(self.address, self.receive)\n\n    def receive(self, address, *args):\n        # FIXME: ip:port/args\n        '''\n        v: first argument to the handler is the IP:port of the sender\n        v: or you can use dispatcher.map directly\n           and not set needs_reply_address=True\n        j: can I get ip:port from osc itself?\n        v: if you know the sender ahead of time yeah,\n           but that lets you respond to different senders dynamically\n        '''\n        self.set(args[1:])\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCReceiveUpdater.receive","title":"<code>receive(address, *args)</code>","text":"<p>v: first argument to the handler is the IP:port of the sender v: or you can use dispatcher.map directly    and not set needs_reply_address=True j: can I get ip:port from osc itself? v: if you know the sender ahead of time yeah,    but that lets you respond to different senders dynamically</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def receive(self, address, *args):\n    # FIXME: ip:port/args\n    '''\n    v: first argument to the handler is the IP:port of the sender\n    v: or you can use dispatcher.map directly\n       and not set needs_reply_address=True\n    j: can I get ip:port from osc itself?\n    v: if you know the sender ahead of time yeah,\n       but that lets you respond to different senders dynamically\n    '''\n    self.set(args[1:])\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCReceiveUpdaters","title":"<code>OSCReceiveUpdaters</code>","text":"<p>o = OSCReceiveUpdaters(osc,     {\"/tolvera/particles/pos\": s.osc_set_pos,      \"/tolvera/particles/vel\": s.osc_set_vel})</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>class OSCReceiveUpdaters:\n    '''\n    o = OSCReceiveUpdaters(osc,\n        {\"/tolvera/particles/pos\": s.osc_set_pos,\n         \"/tolvera/particles/vel\": s.osc_set_vel})\n    '''\n\n    def __init__(self, osc, receives=None, count=10):\n        self.osc = osc\n        self.receives = []\n        self.count = count\n        if receives is not None:\n            self.add_dict(receives, count=self.count)\n\n    def add_dict(self, receives, count=None):\n        if count is None:\n            count = self.count\n        {a: self.add(a, f, count=count) for a, f in receives.items()}\n\n    def add(self, address, function, state=None, count=None, update=False):\n        if count is None:\n            count = self.count\n        self.receives.append(\n            OSCReceiveUpdater(self.osc, address, function,\n                              state, count, update))\n\n    def __call__(self):\n        [r() for r in self.receives]\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCSend","title":"<code>OSCSend</code>","text":"<p>Non rate-limited OSC send</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>class OSCSend():\n    '''\n    Non rate-limited OSC send\n    '''\n    def __init__(self, osc, address: str, f, count=30, client=None):\n        self.osc = osc\n        self.address = address\n        self.f = f\n        self.client = client\n\n    def __call__(self, *args):\n        self.osc.send(self.address, *self.f(*args), client=self.client)\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCSendUpdater","title":"<code>OSCSendUpdater</code>","text":"<p>Rate-limited OSC send</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>class OSCSendUpdater():\n    '''\n    Rate-limited OSC send\n    '''\n\n    def __init__(self, osc, address: str, f, count=30, client=None):\n        self.osc = osc\n        self.address = address\n        self.f = f\n        self.count = count\n        self.counter = 0\n        self.client = client\n\n    def __call__(self):\n        self.counter += 1\n        if self.counter &gt;= self.count:\n            self.osc.send(self.address, *self.f(), client=self.client)\n            self.counter = 0\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCSendUpdaters","title":"<code>OSCSendUpdaters</code>","text":"<p>o = OSCSendUpdaters(osc, client=\"particles\", count=10,     sends={         \"/tolvera/particles/get/pos/all\": s.osc_get_pos_all     })</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>class OSCSendUpdaters:\n    '''\n    o = OSCSendUpdaters(osc, client=\"particles\", count=10,\n        sends={\n            \"/tolvera/particles/get/pos/all\": s.osc_get_pos_all\n        })\n    '''\n\n    def __init__(self, osc, sends=None, count=10, client=None):\n        self.osc = osc\n        self.sends = []\n        self.count = count\n        self.client = client\n        if sends is not None:\n            self.add_dict(sends, self.count, self.client)\n\n    def add_dict(self, sends, count=None, client=None):\n        if count is None:\n            count = self.count\n        if client is None:\n            client = self.client\n        {a: self.add(a, f, count=count, client=client)\n                     for a, f in sends.items()}\n\n    def add(self, address, function, state=None, count=None, update=False, client=None):\n        if count is None:\n            count = self.count\n        if client is None:\n            client = self.client\n        self.sends.append(\n            OSCSendUpdater(self.osc, address, function, count, client))\n\n    def __call__(self):\n        [s() for s in self.sends]\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.OSCUpdaters","title":"<code>OSCUpdaters</code>","text":"<p>o = OSCUpdaters(osc, client=\"boids\", count=10,     receives={         \"/tolvera/boids/pos\": b.osc_set_pos,         \"/tolvera/boids/vel\": b.osc_set_vel     },     sends={         \"/tolvera/boids/pos/all\": b.osc_get_all_pos     } )</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>class OSCUpdaters:\n    '''\n    o = OSCUpdaters(osc, client=\"boids\", count=10,\n        receives={\n            \"/tolvera/boids/pos\": b.osc_set_pos,\n            \"/tolvera/boids/vel\": b.osc_set_vel\n        },\n        sends={\n            \"/tolvera/boids/pos/all\": b.osc_get_all_pos\n        }\n    )\n    '''\n\n    def __init__(self, osc,\n                 sends=None, receives=None,\n                 send_count=60, receive_count=10,\n                 client=None):\n        self.osc = osc\n        self.client = client\n        self.send_count = send_count\n        self.receive_count = receive_count\n        self.sends = OSCSendUpdaters(\n            self.osc, count=self.send_count, client=self.client)\n        self.receives = OSCReceiveUpdaters(self.osc, count=self.receive_count)\n        if sends is not None:\n            self.add_sends(sends)\n        if receives is not None:\n            self.add_receives(receives)\n\n    def add_sends(self, sends, count=None, client=None):\n        if count is None:\n            count = self.send_count\n        if client is None:\n            client = self.client\n        self.sends.add_dict(sends, count, client)\n\n    def add_send(self, send, count=None, client=None):\n        if count is None:\n            count = self.send_count\n        if client is None:\n            client = self.client\n        self.sends.add(send, client=client, count=count)\n\n    def add_receives(self, receives, count=None):\n        if count is None:\n            count = self.receive_count\n        self.receives.add_dict(receives, count=count)\n\n    def add_receive(self, receive, count=None):\n        if count is None:\n            count = self.receive_count\n        self.receives.add(receive, count=count)\n\n    def __call__(self):\n        self.sends()\n        self.receives()\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.ReceiveListUpdater","title":"<code>ReceiveListUpdater</code>","text":"<p>Decouples event handling from updating Updating is rate-limited by a counter Assumes a list[float] instead of *args</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>class ReceiveListUpdater:\n    '''\n    Decouples event handling from updating\n    Updating is rate-limited by a counter\n    Assumes a list[float] instead of *args\n    '''\n\n    def __init__(self, f, state=None, count=5, update=False):\n        self.f = f\n        self.count = count\n        self.counter = 0\n        self.update = update\n        self.state = state\n\n    def set(self, state):\n        '''\n        Set the Updater's state\n        '''\n        self.state = state\n        self.update = True\n\n    def __call__(self):\n        '''\n        Update the target function with internal state\n        '''\n        self.counter += 1\n        if not (self.update and\n                self.counter &gt; self.count and\n                self.state is not None):\n            return\n        self.f(self.state)\n        self.counter = 0\n        self.update = False\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.ReceiveListUpdater.__call__","title":"<code>__call__()</code>","text":"<p>Update the target function with internal state</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def __call__(self):\n    '''\n    Update the target function with internal state\n    '''\n    self.counter += 1\n    if not (self.update and\n            self.counter &gt; self.count and\n            self.state is not None):\n        return\n    self.f(self.state)\n    self.counter = 0\n    self.update = False\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.ReceiveListUpdater.set","title":"<code>set(state)</code>","text":"<p>Set the Updater's state</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def set(self, state):\n    '''\n    Set the Updater's state\n    '''\n    self.state = state\n    self.update = True\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.ReceiveUpdater","title":"<code>ReceiveUpdater</code>","text":"<p>Decouples event handling from updating Updating is rate-limited by a counter</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>class ReceiveUpdater:\n    '''\n    Decouples event handling from updating\n    Updating is rate-limited by a counter\n    '''\n\n    def __init__(self, f, state=None, count=5, update=False):\n        self.f = f\n        self.count = count\n        self.counter = 0\n        self.update = update\n        self.state = state\n\n    def set(self, state):\n        '''\n        Set the Updater's state\n        '''\n        self.state = state\n        self.update = True\n\n    def __call__(self):\n        '''\n        Update the target function with internal state\n        '''\n        self.counter += 1\n        if not (self.update and\n                self.counter &gt; self.count and\n                self.state is not None):\n            return\n        self.f(*self.state)\n        self.counter = 0\n        self.update = False\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.ReceiveUpdater.__call__","title":"<code>__call__()</code>","text":"<p>Update the target function with internal state</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def __call__(self):\n    '''\n    Update the target function with internal state\n    '''\n    self.counter += 1\n    if not (self.update and\n            self.counter &gt; self.count and\n            self.state is not None):\n        return\n    self.f(*self.state)\n    self.counter = 0\n    self.update = False\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.ReceiveUpdater.set","title":"<code>set(state)</code>","text":"<p>Set the Updater's state</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>def set(self, state):\n    '''\n    Set the Updater's state\n    '''\n    self.state = state\n    self.update = True\n</code></pre>"},{"location":"reference/iipyper/osc/#iipyper.osc.Updater","title":"<code>Updater</code>","text":"<p>Rate-limited function call</p> Source code in <code>src/iipyper/osc.py</code> <pre><code>class Updater():\n    '''\n    Rate-limited function call\n    '''\n\n    def __init__(self, f, count=30):\n        self.f = f\n        self.count = count\n        self.counter = 0\n\n    def __call__(self):\n        self.counter += 1\n        if self.counter &gt;= self.count:\n            self.f()\n            self.counter = 0\n</code></pre>"},{"location":"reference/iipyper/state/","title":"State","text":""},{"location":"reference/iipyper/timing/","title":"Timing","text":""},{"location":"reference/iipyper/timing/#iipyper.timing.Stopwatch","title":"<code>Stopwatch</code>","text":"Source code in <code>src/iipyper/timing.py</code> <pre><code>class Stopwatch:\n    def __init__(self, punch:bool=True):\n        self.t = None\n        if punch:\n            self.punch()\n\n    def punch(self, latency:float=0):\n        \"\"\"punch the clock and return elapsed time since previous punch\n\n        Args:\n            latency: punch `latency` seconds in the past, \n                unless it would be before the previous punch\n        \"\"\"\n        t = time.perf_counter_ns() - latency\n        if self.t is None:\n            dt_ns = 0\n        else:\n            t = max(self.t, t)\n            dt_ns = t - self.t\n        self.t = t\n        return dt_ns * 1e-9\n\n    def read(self):\n        \"\"\"just return elapsed time since last punch\"\"\"\n        if self.t is None:\n            return self.punch()\n        return (time.perf_counter_ns() - self.t) * 1e-9\n</code></pre>"},{"location":"reference/iipyper/timing/#iipyper.timing.Stopwatch.punch","title":"<code>punch(latency=0)</code>","text":"<p>punch the clock and return elapsed time since previous punch</p> <p>Parameters:</p> Name Type Description Default <code>latency</code> <code>float</code> <p>punch <code>latency</code> seconds in the past,  unless it would be before the previous punch</p> <code>0</code> Source code in <code>src/iipyper/timing.py</code> <pre><code>def punch(self, latency:float=0):\n    \"\"\"punch the clock and return elapsed time since previous punch\n\n    Args:\n        latency: punch `latency` seconds in the past, \n            unless it would be before the previous punch\n    \"\"\"\n    t = time.perf_counter_ns() - latency\n    if self.t is None:\n        dt_ns = 0\n    else:\n        t = max(self.t, t)\n        dt_ns = t - self.t\n    self.t = t\n    return dt_ns * 1e-9\n</code></pre>"},{"location":"reference/iipyper/timing/#iipyper.timing.Stopwatch.read","title":"<code>read()</code>","text":"<p>just return elapsed time since last punch</p> Source code in <code>src/iipyper/timing.py</code> <pre><code>def read(self):\n    \"\"\"just return elapsed time since last punch\"\"\"\n    if self.t is None:\n        return self.punch()\n    return (time.perf_counter_ns() - self.t) * 1e-9\n</code></pre>"},{"location":"reference/iipyper/timing/#iipyper.timing.Timer","title":"<code>Timer</code>","text":"<p>a threading.Timer using the global iipyper lock around the timed function. also starts automatically by default.</p> Source code in <code>src/iipyper/timing.py</code> <pre><code>class Timer:\n    \"\"\"a threading.Timer using the global iipyper lock around the timed function.\n    also starts automatically by default.\n    \"\"\"\n    def __init__(self, interval, f, lock=True, start=True, **kw):\n        self.timer = _Timer(max(0,interval), maybe_lock(f, lock), **kw)\n        if start:\n            self.start()\n    def cancel(self):\n        self.timer.cancel()\n    def start(self):\n        self.timer.start()\n</code></pre>"},{"location":"reference/iipyper/tui/","title":"Tui","text":""},{"location":"reference/iipyper/types/","title":"Types","text":"<p><code>from iipyper.types import *</code> to get a set of types to use with <code>OSC.handle</code></p>"},{"location":"reference/iipyper/types/#iipyper.types.Splat","title":"<code>Splat</code>","text":"<p>horrible typing crimes to produce annotations for _consume_items which pydantic can also validate out of the box.</p> <p><code>Splat[None]</code> aliases <code>List</code></p> <p><code>Splat[2]</code> aliases <code>Tuple[Any, Any]</code></p> <p><code>Splat[3]</code> aliases <code>Tuple[Any, Any, Any]</code></p> <p>etc</p> Source code in <code>src/iipyper/types.py</code> <pre><code>class Splat(metaclass=_Splat):\n    \"\"\"horrible typing crimes to produce annotations for _consume_items\n    which pydantic can also validate out of the box.\n\n    `Splat[None]` aliases `List`\n\n    `Splat[2]` aliases `Tuple[Any, Any]`\n\n    `Splat[3]` aliases `Tuple[Any, Any, Any]`\n\n    etc\n    \"\"\"\n</code></pre>"},{"location":"reference/iipyper/util/","title":"Util","text":""}]}